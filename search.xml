<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 字符串比较大小的原理</title>
    <url>/posts/60551/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%87%BA">问题引出</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%8E%9F%E7%90%86">字符串比较大小的原理</a></li>
</ul>
<!-- /TOC -->
<h2 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h2><p>笔者在比较两个字符串大小的时候踩过的坑，本意是想利用数值型对应的字符串的形式比较字符串本身的大小，例如：<code>&quot;21&quot; &gt; &quot;111&quot;</code>显然对于数值型的<code>21 &gt; 111</code>】结果肯定为false,但是<code>&quot;21&quot; &gt; &quot;111&quot;</code>的结果为true</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">&quot;21&quot;</span>, s2 = <span class="string">&quot;111&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">21</span>, n2 = <span class="number">111</span>;</span><br><span class="line">    <span class="keyword">bool</span> res = (n1 &gt; n2);   </span><br><span class="line">    <span class="keyword">bool</span> res1 = (s1 &gt; s2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(n1 &gt; n2) = &quot;</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(s1 &gt; s2) = &quot;</span> &lt;&lt; res1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串比较大小的原理"><a href="#字符串比较大小的原理" class="headerlink" title="字符串比较大小的原理"></a>字符串比较大小的原理</h2><p>首先看下《C++ Primer》这本书中的描述：<img src="https://i.loli.net/2020/12/08/qz53rNOLuHlYWZ4.png" alt="image.png"><br>原理：字符串中第一个相异的字符比较的结果<br>明确以下几点：</p>
<ol>
<li>两个字符串是可以用【&gt;,&lt;,&gt;=,&lt;=】来比较大小的</li>
<li>对于数值型对应的字符串形式，<ul>
<li>两个字符串长度相等的情况下，例如：<code>&quot;12&quot; &lt; &quot;22&quot;</code>，是可以比较出两个字符串对应的原数值型数据的大小关系</li>
<li>两个字符串长度不等的情况下，无法比较出其对应数值型的大小关系，因为比较的结果取决于从左向右遇到的第一个不等的字符。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">&quot;21&quot;</span>, s1 = <span class="string">&quot;11&quot;</span>, s2 = <span class="string">&quot;111&quot;</span>; </span><br><span class="line">    <span class="comment">// TODO：长度相等的字符串比较的结果   </span></span><br><span class="line">    <span class="keyword">bool</span> res = (s &gt; s1);   </span><br><span class="line">    <span class="comment">// TODO：长度不等的字符串比较的结果</span></span><br><span class="line">    <span class="keyword">bool</span> res1 = (s &gt; s2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(\&quot;21\&quot; &gt; \&quot;11\&quot;) = &quot;</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(\&quot;21\&quot; &gt; \&quot;111\&quot;) = &quot;</span> &lt;&lt; res1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="string">&quot;21&quot;</span> &gt; <span class="string">&quot;11&quot;</span>) = <span class="number">1</span></span><br><span class="line">(<span class="string">&quot;21&quot;</span> &gt; <span class="string">&quot;111&quot;</span>) = <span class="number">1</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>编程中踩过的坑</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>My first blog</title>
    <url>/posts/11206/</url>
    <content><![CDATA[<p>2020年12月6日晚8：52分  周日 主楼实验室 沈阳</p>
<p>在2020年的最后一个月搭建好了个人博客，即将开始博客之旅，将自己的学习笔记，成长轨迹，生活中的点滴，记录在这里。初次搭完博客，还有些许的成就感，当然要完善的地方还有很多，目前而言能够发布文章，以及文章的一些统计功能，还有站点的一些统计功能。一些按钮还未设置好。</p>
<p>博客的主题采用hexo中使用量最多的next主题，重点考虑到用的人多，遇到问题更容易找到解决办法。</p>
<p>新的开始，加油~~~</p>
]]></content>
      <categories>
        <category>成长轨迹</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode62.Unique Paths</title>
    <url>/posts/3208550628/</url>
    <content><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><strong>Example 1:</strong><br><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="图片"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: m &#x3D; 3, n &#x3D; 7</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right</span><br><span class="line">3. Down -&gt; Right -&gt; Down</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: m &#x3D; 3, n &#x3D; 3</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>1 &lt;= m, n &lt;= 100</li>
<li>It’s guaranteed that the answer will be less than or equal to 2 * 109.</li>
</ul>
<p><strong>题目链接：</strong></p>
<ul>
<li>中文站：<a href="https://leetcode-cn.com/problems/unique-paths/">https://leetcode-cn.com/problems/unique-paths/</a></li>
<li>英文站：<a href="https://leetcode.com/problems/unique-paths/">https://leetcode.com/problems/unique-paths/</a></li>
</ul>
<h2 id="基本思想1：动态规划"><a href="#基本思想1：动态规划" class="headerlink" title="基本思想1：动态规划"></a>基本思想1：动态规划</h2><ul>
<li>dp[i]：到达该行第i列的路径数</li>
<li>状态：网格的每一个位置</li>
<li>选择：从上面到达该位置，或者从左面到达该位置</li>
<li>状态转移方程：dp[i] = dp[i] + dp[i - 1]，这里其实是用的降维后的dp，<ul>
<li>等号右面的dp[i]表示上一行第i列的路径数</li>
<li>等号右面的dp[i - 1]表示本行第i - 1列的路径数</li>
<li>初始条件：对于第0行和第0列结果都为1</li>
</ul>
</li>
</ul>
<h3 id="cpp版本"><a href="#cpp版本" class="headerlink" title="cpp版本"></a>cpp版本</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                dp[j] += (j &gt; <span class="number">0</span>? dp[j - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="python版本"><a href="#python版本" class="headerlink" title="python版本"></a>python版本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                dp[j] += (dp[j - <span class="number">1</span>] <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h2 id="基本思想2：dfs"><a href="#基本思想2：dfs" class="headerlink" title="基本思想2：dfs"></a>基本思想2：dfs</h2><ul>
<li>核心思想：从当前点走到终点的路径数 = 向右的路径的数 + 向左的路径的数</li>
<li>dfs的过程中，为了提高程序运行的效率，采用记忆化dfs，即保存下当前位置的结果，因为会多次从当前位置进行dfs。（可以画一下dfs的递归树看一下）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        mp = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> mp</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> x == m - <span class="number">1</span> <span class="keyword">and</span> y == n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> x == m <span class="keyword">or</span> y == n:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            k = <span class="built_in">str</span>(x) + <span class="string">&quot;*&quot;</span> + <span class="built_in">str</span>(y)</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> mp.keys():</span><br><span class="line">                <span class="keyword">return</span> mp[k]</span><br><span class="line">                </span><br><span class="line">            down = dfs(x + <span class="number">1</span>, y)</span><br><span class="line">            right = dfs(x, y + <span class="number">1</span>)</span><br><span class="line">            mp[k] = down + right</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> mp[k]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode649.Dota2 Senate</title>
    <url>/posts/2004464160/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>In the world of Dota2, there are two parties: the Radiant and the Dire.</p>
<p>The Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:</p>
<p>Ban one senator’s right:</p>
<ul>
<li>A senator can make another senator lose all his rights in this and all the following rounds.<br>Announce the victory:</li>
<li>If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.</li>
</ul>
<p>Given a string representing each senator’s party belonging. The character ‘R’ and ‘D’ represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n.</p>
<p>The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.</p>
<p>Suppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;RD&quot;
Output: &quot;Radiant&quot;
Explanation: The first senator comes from Radiant and he can just ban the next senator&#39;s right in the round 1. 
And the second senator can&#39;t exercise any rights any more since his right has been banned. 
And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;RDD&quot;
Output: &quot;Dire&quot;
Explanation: 
The first senator comes from Radiant and he can just ban the next senator&#39;s right in the round 1. 
And the second senator can&#39;t exercise any rights anymore since his right has been banned. 
And the third senator comes from Dire and he can ban the first senator&#39;s right in the round 1. 
And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.</code></pre>
<p><strong>Note:</strong></p>
<ul>
<li>The length of the given string will in the range [1, 10,000].</li>
</ul>
<p><strong>题目链接：</strong></p>
<ul>
<li>中文站：<a href="https://leetcode-cn.com/problems/dota2-senate/">https://leetcode-cn.com/problems/dota2-senate/</a></li>
<li>英文站：<a href="https://leetcode.com/problems/dota2-senate/">https://leetcode.com/problems/dota2-senate/</a></li>
</ul>
<h2 id="基本思想：贪心"><a href="#基本思想：贪心" class="headerlink" title="基本思想：贪心"></a>基本思想：贪心</h2><p>首先明确一下问题：</p>
<ul>
<li>为了保证自己方获胜，每一轮禁掉对方一个人的权利</li>
<li>当一方的权利全部被禁掉的时候，另一方就是胜方</li>
</ul>
<p><strong>Q：</strong>禁掉对方的权利时，对方有多名候选人，该禁掉哪一个？<br><strong>A：</strong>贪心思想，禁掉对方的候选人中能够最早行使权力的那一个，因为如果禁掉最晚行使权力的那一个，可能等到它行使权力的时候，我方已经输了</p>
<p>解决方法：</p>
<ul>
<li>维护两个队列，保存每一个候选人行使权力的时间</li>
<li>两个队列的队头元素中，谁的时间早，谁就行使权力，每次禁掉对方的队头元素的权利，自己下一次行使权力的时间为当前时间 + 原始字符串的长度（能够保证比当前轮次所有候选人的时间都大）</li>
</ul>
<p>注意：这里加的是最初的字符串的长度，而不是删除候选人之后的长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">predictPartyVictory</span><span class="params">(<span class="built_in">string</span> senate)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; rq, dq;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>, n = senate.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s : senate)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s == <span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">                rq.push(time++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dq.push(time++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!rq.empty() &amp;&amp; !dq.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(rq.front() &lt; dq.front())&#123;</span><br><span class="line">                dq.pop();</span><br><span class="line">                rq.push(rq.front() + n);</span><br><span class="line">                rq.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                rq.pop();</span><br><span class="line">                dq.push(dq.front() + n);</span><br><span class="line">                dq.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rq.empty()? <span class="string">&quot;Dire&quot;</span> : <span class="string">&quot;Radiant&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode842.Split Array into Fibonacci Sequence</title>
    <url>/posts/30354/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3dfs%E5%89%AA%E6%9E%9D">基本思想：dfs+剪枝</a><ul>
<li><a href="#cpp%E7%89%88%E6%9C%AC">cpp版本</a></li>
<li><a href="#python%E7%89%88%E6%9C%AC">python版本</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a string S of digits, such as S = “123456579”, we can split it into a Fibonacci-like sequence [123, 456, 579].</p>
<p>Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:</p>
<ul>
<li>0 &lt;= F[i] &lt;= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type);</li>
<li>F.length &gt;= 3;</li>
<li>and F[i] + F[i+1] = F[i+2] for all 0 &lt;= i &lt; F.length - 2.</li>
</ul>
<p>Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.</p>
<p>Return any Fibonacci-like sequence split from S, or return [] if it cannot be done.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;123456579&quot;</span><br><span class="line">Output: [123,456,579]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;11235813&quot;</span><br><span class="line">Output: [1,1,2,3,5,8,13]</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;112358130&quot;</span><br><span class="line">Output: []</span><br><span class="line">Explanation: The task is impossible.</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;0123&quot;</span><br><span class="line">Output: []</span><br><span class="line">Explanation: Leading zeroes are not allowed, so &quot;01&quot;, &quot;2&quot;, &quot;3&quot; is not valid.</span><br></pre></td></tr></table></figure>
<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;1101111&quot;</span><br><span class="line">Output: [110, 1, 111]</span><br><span class="line">Explanation: The output [11, 0, 11, 11] would also be accepted.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>1 &lt;= S.length &lt;= 200</li>
<li>S contains only digits.</li>
</ul>
<p><strong>题目链接：</strong></p>
<ul>
<li>英文站：<a href="https://leetcode.com/problems/split-array-into-fibonacci-sequence/">https://leetcode.com/problems/split-array-into-fibonacci-sequence/</a></li>
<li>中文站：<a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/">https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/</a></li>
</ul>
<h2 id="基本思想：dfs-剪枝"><a href="#基本思想：dfs-剪枝" class="headerlink" title="基本思想：dfs+剪枝"></a>基本思想：dfs+剪枝</h2><ul>
<li>借助dfs考虑每一种情况</li>
<li>并配合剪枝操作，剪枝的思想：如果已处理的数据中，前两个数的和已经比当前数小了，就没有必要继续往后扩增当前数了</li>
<li>关键点：处理下数值越界的情况：<ul>
<li>首先是当前数本身不能超过<code>INT_MAX</code>，具体处理方法见程序，要特别注意：只有当两个字符串长度相等的时候，才能用字符串的形式正确的比较出其对应的数值的大小</li>
<li>再者已处理的数据中前两个数的和不能超过<code>INT_MAX</code>，这里可用强制类型转化处理</li>
</ul>
</li>
</ul>
<h3 id="cpp版本"><a href="#cpp版本" class="headerlink" title="cpp版本"></a>cpp版本</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">splitIntoFibonacci</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        dfs(S, <span class="number">0</span>, res, &#123;&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.size() &gt; <span class="number">2</span> &amp;&amp; pos == S.length())&#123;</span><br><span class="line">            res = cur;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(S[pos] == <span class="string">&#x27;0&#x27;</span>)&#123;<span class="comment">//当起始位置是0的时候，0只能单独作为一个数</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cur.size() &lt; <span class="number">2</span> || (cur.size() &gt;= <span class="number">2</span> &amp;&amp; cur[cur.size() - <span class="number">2</span>] + cur[cur.size() - <span class="number">1</span>] == <span class="number">0</span>)) &#123;</span><br><span class="line">                cur.push_back(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> dfs(S, pos + <span class="number">1</span>, res, cur);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> s1 = <span class="string">&quot;2147483647&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; S.length() &amp;&amp; !flag; ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> temp = S.substr(pos, i - pos + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// TODO：处理下当前数本身越界的情况</span></span><br><span class="line">            <span class="keyword">if</span>((temp.size() == s1.size() &amp;&amp; temp &gt; s1) || temp.size() &gt; s1.size())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> num = atoi(temp.c_str());</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> pre_2sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.size() &gt;= <span class="number">2</span>)&#123;              </span><br><span class="line">                pre_2sum = (<span class="keyword">long</span> <span class="keyword">long</span>)cur[cur.size() - <span class="number">2</span>] + (<span class="keyword">long</span> <span class="keyword">long</span>)cur[cur.size() - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span>处理下前两个数相加越界的情况</span></span><br><span class="line">                <span class="keyword">if</span>(pre_2sum &gt; INT_MAX)&#123; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// TODO：前两个数的和小于当前数，就没有必要继续往下dfs了，因为后面的数只会越来越大</span></span><br><span class="line">                <span class="keyword">if</span>(pre_2sum &lt; num) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.size() &lt; <span class="number">2</span> || (cur.size() &gt;= <span class="number">2</span> &amp;&amp; pre_2sum == num)) &#123;</span><br><span class="line">                cur.push_back(num);</span><br><span class="line">                flag = dfs(S, i + <span class="number">1</span>, res, cur);</span><br><span class="line">                cur.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="python版本"><a href="#python版本" class="headerlink" title="python版本"></a>python版本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitIntoFibonacci</span>(<span class="params">self, S: <span class="built_in">str</span></span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">pos: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">            <span class="keyword">if</span> pos == <span class="built_in">len</span>(S):</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">len</span>(res) &gt;= <span class="number">3</span></span><br><span class="line">            </span><br><span class="line">         </span><br><span class="line">            <span class="comment"># if S[pos] == &#x27;0&#x27;:</span></span><br><span class="line">            <span class="comment">#     if len(res) &lt; 2 or (len(res) &gt;= 2 and res[-2] + res[-1] == 0):</span></span><br><span class="line">            <span class="comment">#         res.append(0)</span></span><br><span class="line">            <span class="comment">#         return dfs(pos + 1)</span></span><br><span class="line">            <span class="comment">#     else:</span></span><br><span class="line">            <span class="comment">#         return False</span></span><br><span class="line">            </span><br><span class="line">            s1 = <span class="string">&quot;2147483647&quot;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos, <span class="built_in">len</span>(S)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; pos <span class="keyword">and</span> S[pos] == <span class="string">&quot;0&quot;</span>: <span class="comment">## 处理以0开头的情况，不知道为什么上面的处理方法用python来实现就不行呢！！</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                temp = S[pos : i + <span class="number">1</span>]</span><br><span class="line">                num = <span class="built_in">int</span>(temp)</span><br><span class="line">                print(temp)</span><br><span class="line">                <span class="keyword">if</span> num &gt; <span class="number">2147483647</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">                pre_2sum = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt;= <span class="number">2</span>:</span><br><span class="line">                    pre_2sum = res[-<span class="number">1</span>] + res[-<span class="number">2</span>]</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> pre_2sum &gt; <span class="number">2147483647</span>:</span><br><span class="line">                        <span class="keyword">break</span>                    </span><br><span class="line">                    <span class="keyword">if</span> pre_2sum &lt; num:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                        </span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; <span class="number">2</span> <span class="keyword">or</span> (<span class="built_in">len</span>(res) &gt;= <span class="number">2</span> <span class="keyword">and</span> pre_2sum == num):</span><br><span class="line">                    res.append(num)</span><br><span class="line">                    <span class="keyword">if</span> dfs(i + <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    res.pop()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">                    </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode860.Lemonade Change</title>
    <url>/posts/1739017705/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>At a lemonade stand, each lemonade costs $5. </p>
<p>Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills).</p>
<p>Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.</p>
<p>Note that you don’t have any change in hand at first.</p>
<p>Return true if and only if you can provide every customer with correct change.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [5,5,5,10,20]
Output: true
Explanation: 
From the first 3 customers, we collect three $5 bills in order.
From the fourth customer, we collect a $10 bill and give back a $5.
From the fifth customer, we give a $10 bill and a $5 bill.
Since all customers got correct change, we output true.</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: [5,5,10]
Output: true</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: [10,10]
Output: false</code></pre>
<p><strong>Example 4:</strong></p>
<pre><code>Input: [5,5,10,10,20]
Output: false
Explanation: 
From the first two customers in order, we collect two $5 bills.
For the next two customers in order, we collect a $10 bill and give back a $5 bill.
For the last customer, we can&#39;t give change of $15 back because we only have two $10 bills.
Since not every customer received correct change, the answer is false.</code></pre>
<p><strong>Note:</strong></p>
<ul>
<li>0 &lt;= bills.length &lt;= 10000</li>
<li>bills[i] will be either 5, 10, or 20.</li>
</ul>
<p><strong>题目链接：</strong></p>
<ul>
<li>中文站：<a href="https://leetcode-cn.com/problems/lemonade-change/">https://leetcode-cn.com/problems/lemonade-change/</a></li>
<li>英文站：<a href="https://leetcode.com/problems/lemonade-change/">https://leetcode.com/problems/lemonade-change/</a></li>
</ul>
<h2 id="基本思想：数组遍历"><a href="#基本思想：数组遍历" class="headerlink" title="基本思想：数组遍历"></a>基本思想：数组遍历</h2><ul>
<li>将 $5, $10, $20 各有多少张保存在map中</li>
<li>遍历 bills 数组，每次判断能否找零，从 $20 开始判断，即找零的面值从大到小开始判断</li>
</ul>
<h3 id="cpp-版本"><a href="#cpp-版本" class="headerlink" title="cpp 版本"></a>cpp 版本</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lemonadeChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ump;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; moneys = &#123;<span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> bill : bills)&#123;</span><br><span class="line">            ump[bill]++;</span><br><span class="line">            <span class="keyword">int</span> last_money = bill - <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> &amp;&amp; last_money; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = last_money / moneys[i];</span><br><span class="line">                <span class="keyword">if</span>(cnt &lt;= ump[moneys[i]])&#123;</span><br><span class="line">                    ump[moneys[i]] -= cnt;</span><br><span class="line">                    last_money -= cnt * moneys[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    last_money -= ump[moneys[i]] * cnt;</span><br><span class="line">                    ump[moneys[i]] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(last_money)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="python-版本"><a href="#python-版本" class="headerlink" title="python 版本"></a>python 版本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lemonadeChange</span>(<span class="params">self, bills: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        ump = &#123;<span class="number">5</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">20</span>:<span class="number">0</span>&#125;</span><br><span class="line">        moneys = [<span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>]</span><br><span class="line">        <span class="keyword">for</span> bill <span class="keyword">in</span> bills:</span><br><span class="line">            ump[bill] += <span class="number">1</span></span><br><span class="line">            last_money = bill - <span class="number">5</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> money <span class="keyword">in</span> moneys:</span><br><span class="line">                <span class="keyword">if</span> last_money == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cnt = last_money // money</span><br><span class="line">                <span class="keyword">if</span> cnt &lt;= ump[money]:</span><br><span class="line">                    last_money -= cnt * money</span><br><span class="line">                    ump[money] -= cnt</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    last_money -= ump[money] * money</span><br><span class="line">                    ump[money] = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> last_money:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode861.Score After Flipping Matrix</title>
    <url>/posts/12814/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E8%B4%AA%E5%BF%83">基本思想：贪心</a><ul>
<li><a href="#cpp%E7%89%88%E6%9C%AC">cpp版本</a></li>
<li><a href="#python%E7%89%88%E6%9C%AC">python版本</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>We have a two dimensional matrix A where each value is 0 or 1.</p>
<p>A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s.</p>
<p>After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.</p>
<p>Return the highest possible score.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Input: [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">Output: <span class="number">39</span></span><br><span class="line">Explanation:</span><br><span class="line">Toggled to [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]].</span><br><span class="line"><span class="number">0b1111</span> + <span class="number">0b1001</span> + <span class="number">0b1111</span> = <span class="number">15</span> + <span class="number">9</span> + <span class="number">15</span> = <span class="number">39</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>1 &lt;= A.length &lt;= 20</li>
<li>1 &lt;= A[0].length &lt;= 20</li>
<li>A[i][j] is 0 or 1.</li>
</ul>
<h2 id="基本思想：贪心"><a href="#基本思想：贪心" class="headerlink" title="基本思想：贪心"></a>基本思想：贪心</h2><p>首先明确一点：对于最终的结果而言，每一行每一列翻转的顺序对最终结果没有影响，即得到最优结果的最后一步是翻转第一行，那么最先翻转第一行和最后翻转第一行对最终的结果没有任何影响。</p>
<p>基于上述思想：</p>
<ul>
<li>为了保证最终的结果最大，首先将第一列全部处理成1，也就是将第一列不是1的行进行翻转</li>
<li>除第一列外的其他列，如果当前列1的个数大于0的个数则进行翻转，同时记录该列的结果</li>
</ul>
<h3 id="cpp版本"><a href="#cpp版本" class="headerlink" title="cpp版本"></a>cpp版本</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">matrixScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO：首先将第一列通过行翻转都转化成 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i][<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A[i].size(); ++j)&#123;</span><br><span class="line">                    A[i][j] = !A[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// TODO：初始化为第一列的结果</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">pow</span>(<span class="number">2</span>, A[<span class="number">0</span>].size() - <span class="number">1</span>) * A.size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// TODO：单独处理每一列,只需保证每一列中的1的个数大于0的个数即可, 并不是真的翻转，只是保存每列的每个元素的得分</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A[<span class="number">0</span>].size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A.size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[j][i])</span><br><span class="line">                    ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            res += <span class="built_in">pow</span>(<span class="number">2</span>, A[<span class="number">0</span>].size() - i - <span class="number">1</span>) * max(cnt, <span class="keyword">int</span>(A.size() - cnt));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="python版本"><a href="#python版本" class="headerlink" title="python版本"></a>python版本</h3><ul>
<li>说明：代码和cpp版本稍微有一点区别，未将第一列单独处理</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrixScore</span>(<span class="params">self, A: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        row = <span class="built_in">len</span>(A)</span><br><span class="line">        col = <span class="built_in">len</span>(A[<span class="number">0</span>])</span><br><span class="line">        res = <span class="built_in">pow</span>(<span class="number">2</span>, col - <span class="number">1</span>) * row</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">            <span class="keyword">if</span> i:</span><br><span class="line">                <span class="comment"># <span class="doctag">TODO:</span>统计该列中1的个数，注意看下对应的该行元素是否为1来决定该行是否被翻转过</span></span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">                    <span class="keyword">if</span> A[j][i] == A[j][<span class="number">0</span>] :</span><br><span class="line">                        cnt += <span class="number">1</span></span><br><span class="line">                res += <span class="built_in">pow</span>(<span class="number">2</span>, col - i - <span class="number">1</span>) * <span class="built_in">max</span>(cnt, row - cnt)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>python 中 nonlocal 和 global 的作用</title>
    <url>/posts/2750345904/</url>
    <content><![CDATA[<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>如下代码，由于对 cpp 十分熟悉，想当然的认为变量 a 的作用域为它所在的这个函数，包括其嵌套函数中也可以使用，然而这种想法在 python 中完全不适用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wfun</span>():</span></span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">        a += <span class="number">4</span></span><br><span class="line">        print(a)</span><br><span class="line">    fun()</span><br><span class="line">wfun()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UnboundLocalError: local variable &#39;a&#39; referenced before assignment</span><br></pre></td></tr></table></figure>
<p>原因在于：fun()函数中的变量a还未定义就使用，那本质上是此时程序认为fun()函数和外层函数中的变量a并无关系。</p>
<p>正确的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wfun</span>():</span></span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> a <span class="comment"># 将a声明成上一级函数wfun中的局部变量</span></span><br><span class="line">        a += <span class="number">4</span></span><br><span class="line">        print(a)</span><br><span class="line">    fun()</span><br><span class="line">wfun()</span><br></pre></td></tr></table></figure>

<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>参考链接：</p>
<ul>
<li><a href="https://blog.csdn.net/xCyansun/article/details/79672634">https://blog.csdn.net/xCyansun/article/details/79672634</a></li>
<li><a href="https://www.cnblogs.com/z360519549/p/5172020.html">https://www.cnblogs.com/z360519549/p/5172020.html</a></li>
</ul>
<p>功能：</p>
<ul>
<li><code>global</code> 关键字修饰变量后，表示声明该变量是全局变量</li>
<li><code>nonlocal</code> 关键字修饰变量后，表示声明该变量是上一级函数中的局部变量，若是上一级函数中不存在该变量，则发生错误</li>
</ul>
<p>使用范围：</p>
<ul>
<li><code>global</code> 关键字可以使用在任何地方，包括上层函数和嵌套函数中，即使是之前未定义的变量</li>
<li><code>nonlocal</code> 关键字只能用于嵌套函数中，并且外层函数中定义了相应的局部变量</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol>
<li><p><code>global</code> 关键字在函数中或其他作用域内修饰的变量表示该变量是全局变量，如果该变量在函数内不会被修改，也可以不用 <code>global</code> 修饰。即全局变量在函数中是可以直接访问的（读操作），但如果对其值进行改变（写操作）必须用 <code>global</code> 关键字声明</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span>        </span><br><span class="line">    print(a)</span><br><span class="line">fun() <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a += <span class="number">3</span>        </span><br><span class="line">    print(a) </span><br><span class="line">fun() <span class="comment"># 6</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>global</code> 关键字可以使用在任何地方，即使是未定义的变量</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wfun</span>():</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">        <span class="keyword">global</span> b <span class="comment"># 将 b 声明为全局变量</span></span><br><span class="line">        b = <span class="number">4</span></span><br><span class="line">        print(b) <span class="comment"># 4 (全局变量 b)</span></span><br><span class="line">    a = <span class="number">5</span> <span class="comment"># wfun函数的局部变量 a</span></span><br><span class="line">    fun() </span><br><span class="line">    print(a) <span class="comment"># 5 (局部变量 a)</span></span><br><span class="line">wfun()</span><br><span class="line">print(b) <span class="comment"># 4 (全局变量 b)</span></span><br></pre></td></tr></table></figure>

<p> python中引用变量的顺序：当前作用域局部变量–&gt;外层作用域变量–&gt;当前模块中的全局变量–&gt;python中内置变量</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wfun</span>():</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">        <span class="keyword">global</span> a <span class="comment"># 将 a 声明为全局变量，但不会影响外层函数wfun中的局部变量 a</span></span><br><span class="line">        a = <span class="number">4</span></span><br><span class="line">        print(a) <span class="comment"># 4 (全局变量 a)</span></span><br><span class="line">    a = <span class="number">5</span> <span class="comment"># wfun函数的局部变量 a</span></span><br><span class="line">    fun() </span><br><span class="line">    print(a) <span class="comment"># 5 (局部变量 a，这里涉及到python引用变量的顺序)</span></span><br><span class="line">wfun()</span><br><span class="line">print(a) <span class="comment"># 4 (全局变量 a)</span></span><br></pre></td></tr></table></figure>
<p> <code>global</code> 声明未定义的变量</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_b</span>():</span></span><br><span class="line">    <span class="keyword">global</span> b <span class="comment"># 声明b为全局变量</span></span><br><span class="line">    b = <span class="number">42</span> <span class="comment"># 定义b，这里要注意下：不能在声明的同时定义</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_global</span>():</span></span><br><span class="line">        <span class="keyword">global</span>  b <span class="comment"># 因为要在该函数内修改，所以要声明下，注意这里修改的是外层的全局变量b</span></span><br><span class="line">        b = b + <span class="number">10</span></span><br><span class="line">        print(b) <span class="comment"># 52</span></span><br><span class="line">    do_global()</span><br><span class="line">    print(b) <span class="comment"># 52</span></span><br><span class="line">add_b()</span><br></pre></td></tr></table></figure>
<p> 对比如下两个程序：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_b</span>():</span></span><br><span class="line">    <span class="comment">#global  b</span></span><br><span class="line">    b = <span class="number">42</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_global</span>():</span></span><br><span class="line">        <span class="keyword">global</span>  b</span><br><span class="line">        b =  <span class="number">10</span></span><br><span class="line">        print(b) <span class="comment"># 10</span></span><br><span class="line">    do_global()</span><br><span class="line">    b  = b + <span class="number">5</span></span><br><span class="line">    print(b) <span class="comment"># 47 (注意下这里是等号右边的b是局部变量b)</span></span><br><span class="line">add_b()</span><br><span class="line">b = b + <span class="number">30</span> <span class="comment"># 40 (注意下这里的b是全局变量b)</span></span><br><span class="line">print(<span class="string">&quot; b = %s &quot;</span> % b)</span><br></pre></td></tr></table></figure>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_b</span>():</span></span><br><span class="line">    <span class="comment">#global  b</span></span><br><span class="line">    <span class="comment">#b = 42</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_global</span>():</span></span><br><span class="line">        <span class="keyword">global</span>  b</span><br><span class="line">        b = <span class="number">10</span></span><br><span class="line">        print(b)</span><br><span class="line">    do_global()</span><br><span class="line">    b = b + <span class="number">20</span> <span class="comment"># 这里的b程序认为是局部变量，但是并没有定义局部变量</span></span><br><span class="line">    print(b)</span><br><span class="line">add_b()</span><br><span class="line">b = b + <span class="number">30</span></span><br><span class="line">print(<span class="string">&quot; b = %s &quot;</span> % b)</span><br><span class="line"><span class="comment"># 程序报错：UnboundLocalError: local variable &#x27;b&#x27; referenced before assignment</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nonlocal</code> 关键字用来在函数或其他作用域内声明其外层函数的变量（非全局变量）。即如果内层函数想使用外层函数的变量（非全局变量）需要用 <code>nonlocal</code> 关键字声明下</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wfun</span>():</span></span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> a</span><br><span class="line">        a += <span class="number">4</span></span><br><span class="line">        print(a)</span><br><span class="line">    fun()</span><br><span class="line">wfun() <span class="comment"># 7</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wfun</span>():</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> a <span class="comment"># 本意是想声明 a 为上层函数中的 a ，但是上层中的 a 是全局变量，所以程序报错：no binding for nonlocal &#x27;a&#x27; found</span></span><br><span class="line">        a += <span class="number">4</span></span><br><span class="line">        print(a)</span><br><span class="line">    fun()</span><br><span class="line">wfun()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>编程中踩过的坑</category>
      </categories>
      <tags>
        <tag>nonlocal</tag>
        <tag>global</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客说明文档</title>
    <url>/posts/44808/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E8%AF%B4%E6%98%8E">本地文件夹说明</a></li>
<li><a href="#hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">hexo常用命令</a></li>
<li><a href="#%E4%B8%BAgithub%E4%BB%93%E5%BA%93%E6%B7%BB%E5%8A%A0readme">为github仓库添加readme</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE%E5%85%B3%E4%BA%8E">添加分类、标签、关于</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD">添加搜索功能</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E5%86%85%E9%93%BE%E6%8E%A5%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F">修改文章内链接文本样式</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5">修改文章链接</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%A0%87">添加博客自定义图标</a></li>
<li><a href="#%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%89%B9%E6%95%88">鼠标点击特效</a></li>
<li><a href="#%E6%96%87%E7%AB%A0%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AE%B0">文章结束标记</a></li>
<li><a href="#%E6%96%87%E7%AB%A0%E9%98%B4%E5%BD%B1%E8%AE%BE%E7%BD%AE">文章阴影设置</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E5%8D%9A%E5%AE%A2%E6%91%98%E8%A6%81%E6%98%BE%E7%A4%BA">设置博客摘要显示</a></li>
<li><a href="#%E5%B0%86%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%9C%A8-githubgitee">将博客同时部署在 github、gitee</a></li>
</ul>
<!-- /TOC -->

<p>本文主要介绍搭建好博客后，如何让博客的内容更加丰富，让博客整体的界面更加美观，以及一些特效的设置</p>
<a id="more"></a>
<h2 id="本地文件夹说明"><a href="#本地文件夹说明" class="headerlink" title="本地文件夹说明"></a>本地文件夹说明</h2><ul>
<li>public：该文件夹最终会被push到github仓库中</li>
<li>source：存放用户资源的地方。<ul>
<li>_posts文件夹中的markdown文档会被解析成html文件并放到public文件夹</li>
<li>除_posts文件及外，其余以【_】开头的文件或文件夹都会被忽略</li>
<li>其余文件（例如：about文件）会被拷贝到public文件夹</li>
</ul>
</li>
</ul>
<ul>
<li>scafflods：模板文件夹。新建markdown文件时，hexo会根据该文件夹下的模板来建立文件<ul>
<li>post.md：新建文章<code>hexo new &quot;文章名&quot;</code>时，会按照该文件中的内容生成默认文件</li>
<li>也可以自己定义模板，例如模板名为blog，新建文章时，为了使用该模板，键入命令<code>hexo new blog &quot;文章名&quot;</code></li>
</ul>
</li>
</ul>
<h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><p>说明：笔者的博客目录名为blog</p>
<ul>
<li><code>hexo new &quot;文章名&quot;</code>：新建文章，在blog文件的路径下键入，最终会在blog/source/_posts文件夹下出现新建的文件</li>
<li><code>hexo g</code>：生成静态页面至public文件夹下：在blog文件夹下键入，它是<code>hexo generate</code>的缩写</li>
<li><code>hexo s</code>：开启本地预览端口，在blog文件夹下键入，它是<code>hexo server</code>的缩写</li>
<li><code>hexo d</code>：部署到github：在blog文件夹下键入，它是<code>hexo deploy</code>的缩写</li>
<li><code>hexo help</code>：查看帮助</li>
<li><code>hexo version</code>：查看hexo版本</li>
</ul>
<p>组合命令：</p>
<ul>
<li><code>hexo s -g</code>：生成静态页面并本地预览</li>
<li><code>hexo d -g</code>：生成静态页面并部署到github</li>
</ul>
<p>注：</p>
<ul>
<li>新建文章：<code>hexo new blog &quot;文章名&quot;</code>，<code>blog</code> 是在文件夹 <code>scaffolds</code> 中建立的 .md 文件，里面定义了新生成的文章的格式</li>
</ul>
<h2 id="为github仓库添加readme"><a href="#为github仓库添加readme" class="headerlink" title="为github仓库添加readme"></a>为github仓库添加readme</h2><p>因为source中的文件会被拷贝到public文件夹中，而public文件夹会被push到github中，因此想为github仓库添加readme，只需在source文件夹中创建即可。<br>注意：source文件夹中的【.md】文档会被解析成html文件，再放到public中。为了避免解析，将readme的扩展名改为【.MDWN】(这里一定要大写，小写的话也会被解析成html文件)</p>
<h2 id="添加分类、标签、关于"><a href="#添加分类、标签、关于" class="headerlink" title="添加分类、标签、关于"></a>添加分类、标签、关于</h2><ul>
<li>首先将站点配置文件中的menu下面的categories和tags前的【#】去掉<img src="https://i.loli.net/2020/12/07/JCdtcQwxAYfT7MX.png" alt="image.png"></li>
<li>创建markdown文件<img src="https://i.loli.net/2020/12/07/DQ5aXjgtFGw83Ey.png" alt="image.png"><ul>
<li>在blog文件夹下键入<code>hexo new page tags</code>，此时会生成blog/source/tags/index.md文件</li>
<li>修改index.md文件，添加【type:”tags”】<img src="https://i.loli.net/2020/12/07/ZUySVMFOIDATw2J.png" alt="image.png"></li>
</ul>
</li>
</ul>
<ul>
<li>在blog文件夹下键入<code>hexo new page categories</code>，此时会生成blog/source/categories/index.md</li>
<li>修改index.md文件，添加【type:”categories”】<img src="https://i.loli.net/2020/12/07/iPwaHA5jQmIVreM.png" alt="image.png"></li>
</ul>
<p>about也是采用同样的方法，就不再赘述了</p>
<h2 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h2><p>参考链接：<a href="https://www.jianshu.com/p/3a05351a37dc">https://www.jianshu.com/p/3a05351a37dc</a></p>
<ol>
<li><p>在 blog 文件夹下执行命令<code>npm install hexo-generator-searchdb --save</code></p>
</li>
<li><p>修改站点配置文件，在Extension下添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></li>
<li><p>修改主题配置文件，找到 Local search，将 enable 设置为 <code>true</code></p>
</li>
</ol>
<h2 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h2><p>参考链接：<a href="https://www.jianshu.com/p/3a05351a37dc">https://www.jianshu.com/p/3a05351a37dc</a></p>
<p>打开文件<code>blog\themes\next\source\css\_common\components\post\post.styl</code>，在末尾添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.post-body p a &#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改文章链接"><a href="#修改文章链接" class="headerlink" title="修改文章链接"></a>修改文章链接</h2><p>参考链接：<a href="https://blog.csdn.net/as480133937/article/details/100138838">https://blog.csdn.net/as480133937/article/details/100138838</a><br>文章链接默认的生成规则<code>:year/:month/:day/:title</code>，生成的样式<code>https://crystal1213.github.io/2020/12/07/leetcode861-Score-After-Flipping-Matrix/</code><br>修改后的样式：<code>https://crystal1213.github.io/posts/30354/</code></p>
<p>生成简洁的url的方法：</p>
<ol>
<li>安装插件，在blog文件夹下键入命令<code>npm install hexo-abbrlink --save </code></li>
<li>修改站点配置文件，找到<code>permalink</code>，修改为如下的形式：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: posts&#x2F;:abbrlink&#x2F;</span><br><span class="line">abbrlink:</span><br><span class="line">	alg: crc32   #算法： crc16(default) and crc32</span><br><span class="line">	rep: hex     #进制： dec(default) and hex</span><br><span class="line"></span><br></pre></td></tr></table></figure>
样式选择：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;66c8.html</span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;65535.html</span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;8ddf18fb.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;1690090958.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="添加博客自定义图标"><a href="#添加博客自定义图标" class="headerlink" title="添加博客自定义图标"></a>添加博客自定义图标</h2><p>参考链接：<a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a><br><img src="https://i.loli.net/2020/12/10/QdxwNLvE8ckIp3z.png" alt="image.png"></p>
<ol>
<li>在以下网站下载或者制作图标 <a href="https://www.iconfont.cn/plus/user/detail?uid=41718">iconfont</a> <a href="https://www.easyicon.net/">easyicon</a> 下载图标，注意下图标的大小</li>
<li>将下载的图标放在 <code>...\blog\themes\next\source\images</code> 文件夹下</li>
<li>修改主题配置文件 <code>favicon</code> 中的 <code>small</code> 和 <code>medium</code> ，改为图标的文件名</li>
</ol>
<h2 id="鼠标点击特效"><a href="#鼠标点击特效" class="headerlink" title="鼠标点击特效"></a>鼠标点击特效</h2><p>参考链接：<a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a></p>
<ol>
<li><p>在<code>/themes/next/source/js/src</code> 下新建文件 <code>clicklove.js</code>，将下面代码拷贝到文件中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">&quot;left:&quot;</span>+d[e].x+<span class="string">&quot;px;top:&quot;</span>+d[e].y+<span class="string">&quot;px;opacity:&quot;</span>+d[e].alpha+<span class="string">&quot;;transform:scale(&quot;</span>+d[e].scale+<span class="string">&quot;,&quot;</span>+d[e].scale+<span class="string">&quot;) rotate(45deg);background:&quot;</span>+d[e].color+<span class="string">&quot;;z-index:99999&quot;</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">&quot;function&quot;</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;div&quot;</span>);a.className=<span class="string">&quot;heart&quot;</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX-<span class="number">5</span>,<span class="attr">y</span>:e.clientY-<span class="number">5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;style&quot;</span>);a.type=<span class="string">&quot;text/css&quot;</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">&quot;rgb(&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;)&quot;</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">setTimeout</span>(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>在文件 <code>\themes\next\layout\_layout.swig</code> 末尾添加如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/src/clicklove.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="文章结束标记"><a href="#文章结束标记" class="headerlink" title="文章结束标记"></a>文章结束标记</h2><p>参考链接：<a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a></p>
<h2 id="文章阴影设置"><a href="#文章阴影设置" class="headerlink" title="文章阴影设置"></a>文章阴影设置</h2><p>参考链接：<a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a><br>设置好后感觉没有效果</p>
<h2 id="设置博客摘要显示"><a href="#设置博客摘要显示" class="headerlink" title="设置博客摘要显示"></a>设置博客摘要显示</h2><p>参考链接：<a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a></p>
<h2 id="将博客同时部署在-github、gitee"><a href="#将博客同时部署在-github、gitee" class="headerlink" title="将博客同时部署在 github、gitee"></a>将博客同时部署在 github、gitee</h2><p>参考链接：<a href="https://blog.csdn.net/weixin_45667885/article/details/101084532">https://blog.csdn.net/weixin_45667885/article/details/101084532</a></p>
<ol>
<li>同时在 github、gitee 上创建好账号、仓库（仓库名和用户名相同）；</li>
<li>在 github、gitee 上添加 SSH Keys；</li>
<li>开启 Pages 服务；</li>
<li>打开站点配置文件，修改 <code>deploy</code> 如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line"> type: git</span><br><span class="line"> repo: </span><br><span class="line">     github: git@github.com:Crystal1213&#x2F;Crystal1213.github.io.git</span><br><span class="line">     gitee: git@gitee.com:Crystal1213&#x2F;crystal1213.git</span><br><span class="line"> branch: master</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>注：gitee Pages 不支持自动更新，每次部署后需要手动更新。</p>
]]></content>
      <categories>
        <category>工具使用说明</category>
      </categories>
      <tags>
        <tag>工具说明</tag>
      </tags>
  </entry>
  <entry>
    <title>git 学习笔记</title>
    <url>/posts/1/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">文件操作</a><ul>
<li><a href="#git-%E5%9F%BA%E7%A1%80">git 基础</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93">创建版本库</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%B7%A5%E4%BD%9C%E5%8C%BA%E7%8A%B6%E6%80%81">查看工作区状态</a></li>
<li><a href="#%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E4%B9%8B%E9%97%B4%E5%88%87%E6%8D%A2">在不同版本之间切换</a></li>
<li><a href="#git%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA">git工作区和暂存区</a></li>
<li><a href="#%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9">撤销修改</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6">删除文件</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">远程仓库</a><ul>
<li><a href="#%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%BB%BA%E7%AB%8B%E5%85%B3%E8%81%94">将本地仓库和远程仓库建立关联</a></li>
<li><a href="#%E5%B0%86%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%8B%E9%9A%86%E5%88%B0%E6%9C%AC%E5%9C%B0">将远程仓库克隆到本地</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E6%94%AF">分支</a><ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF">创建与合并分支</a></li>
<li><a href="#%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E5%87%BA%E7%8E%B0%E5%86%B2%E7%AA%81">合并分支出现冲突</a></li>
<li><a href="#%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E6%97%B6%E4%BF%9D%E7%95%99%E5%8E%86%E5%8F%B2%E5%88%86%E6%94%AF">合并分支时保留历史分支</a></li>
<li><a href="#%E4%BF%AE%E5%A4%8D%E5%85%B6%E4%BB%96%E5%88%86%E6%94%AF%E7%9A%84-bug-%E6%97%B6%E4%BF%9D%E5%AD%98%E8%AF%A5%E5%88%86%E6%94%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8E%B0%E5%9C%BA">修复其他分支的 bug 时，保存该分支的工作现场</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E6%9C%AA%E8%A2%AB%E5%90%88%E5%B9%B6%E7%9A%84%E5%88%86%E6%94%AF">删除未被合并的分支</a></li>
<li><a href="#%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E7%9A%84%E6%AD%A5%E9%AA%A4">多人协作的步骤</a></li>
</ul>
</li>
<li><a href="#%E6%A0%87%E7%AD%BE">标签</a><ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE">创建标签</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E6%A0%87%E7%AD%BE">删除标签</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E4%B8%8E%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE">参与开源项目</a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%E5%A4%9A%E4%B8%AA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">本地仓库关联多个远程仓库</a></li>
<li><a href="#%E5%BF%BD%E7%95%A5%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6">忽略特殊文件</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<!-- /TOC -->

<p>本文主要讲述 git 相关的命令操作</p>
<a id="more"></a>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="git-基础"><a href="#git-基础" class="headerlink" title="git 基础"></a>git 基础</h2><p>git 文件的三种状态：</p>
<ul>
<li>已提交（committed）：表示该文件已经被安全地保存在本地数据库中了</li>
<li>已修改（modified）：表示修改了某个文件，但还没有提交保存</li>
<li>已暂存（staged）：把已修改的文件放在下次提交时要保存的清单中</li>
</ul>
<p>Git 目录：（译注：如果 git clone 出来的话，就是其中 .git 的目录；如果 <code>git clone --bare</code> 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。<br>文件流转的三个工作区域：</p>
<ul>
<li>Git 的工作目录：从项目中取出某个版本的所有文件和目录，用以开始后续工作。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。</li>
<li>暂存区域：所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件。</li>
<li>本地仓库</li>
</ul>
<p>基本的 Git 工作流程如下：</p>
<ol>
<li>在工作目录中修改某些文件。</li>
<li>对修改后的文件进行快照，然后保存到暂存区域。</li>
<li>提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</li>
</ol>
<p>所以，我们可以从文件所处的位置来判断状态：如果是 Git 目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。</p>
<hr>
<p>查看已有的配置信息的命令 <code>git config --list</code><br>配置用户名和邮箱：<code>git config --global user.name &quot;名字&quot;</code> <code>git config --global user.email &quot;邮箱&quot;</code> （<code>global</code> 参数表示这台机器上所有的 git 仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和邮箱）</p>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><ol>
<li>新建一个空的文件夹 learngit ，在该文件夹下执行 <code>git init</code> 命令，初始化一个 Git 仓库。</li>
<li>在 learngit 这个文件夹下新建一个或几个文件，创建文本文件最好用 Notepad++ ，不要用 windows 自带的文本文件，涉及到编码问题</li>
<li>将文件添加到 Git 仓库，分两步：<ul>
<li>使用命令git add <file>，注意，可反复多次使用，添加多个文件；<file>指的是文件名</li>
<li>使用命令git commit -m <message>，完成。<message>表示一些提示性的信息</li>
</ul>
</li>
</ol>
<h2 id="查看工作区状态"><a href="#查看工作区状态" class="headerlink" title="查看工作区状态"></a>查看工作区状态</h2><ul>
<li>查看工作区的状态，执行命令 <code>git status</code></li>
<li>如果文件有被修改，查看文件的不同，执行命令 <code>git diff &lt;文件名&gt;</code>。（比较的是工作区的文件和暂存区的文件的不同，如果想比较当前文件和提交到分支中文件的不同，需要明确指明，例如用命令 <code>git diff HEAD -- readme.txt</code> 比较工作区中的readme.txt文件和提交到分支的readme.txt的不同）</li>
</ul>
<h2 id="在不同版本之间切换"><a href="#在不同版本之间切换" class="headerlink" title="在不同版本之间切换"></a>在不同版本之间切换</h2><ul>
<li>HEAD 指向的版本就是当前版本（HEAD^ 表示上一个版本，HEAD^^ 表示上上个版本，如果是往上100个版本，用 HEAD~100 来表示），因此，Git 允许我们在版本的历史之间穿梭，使用命令 <code>git reset --hard commit_id</code>，commit_id指的是每一个版本的编号，也可以用 HEAD^这种形式来表示</li>
<li><code>git log</code> 命令可以查看提交历史，以便确定要回退到哪个版本。<code>git log --pretty=oneline</code> 将提交的历史在一行显示</li>
<li><code>git reflog</code> 命令查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
<h2 id="git工作区和暂存区"><a href="#git工作区和暂存区" class="headerlink" title="git工作区和暂存区"></a>git工作区和暂存区</h2><ul>
<li>工作区：是指我们所操作的文件所属的文件夹，例如上述例子中的 learngit 文件夹</li>
<li>暂存区：执行 <code>git add &quot;文件名&quot;</code> 命令后，文件会从工作区转移到暂存区</li>
<li>分支：执行 <code>git commit -m &quot;说明信息&quot;</code> 命令后，文件会从暂存区提交到分支</li>
</ul>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><ul>
<li>改变了工作区的内容，想退回到原来（最近一次）的状态，执行命令 <code>git checkout -- &quot;文件名&quot;</code></li>
<li>使文件从暂存区回到工作区，执行命令 <code>git reset HEAD &quot;文件名&quot;</code></li>
</ul>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p><code>git rm &quot;文件名&quot;</code> ：删除分支中的文件<br>如果误删了（在文件夹中删除了，但是分支中没有删除）可以用 <code>git checkout -- &quot;文件名&quot;</code> 使文件夹中该文件的内容恢复到和分支中一样的情形</p>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="将本地仓库和远程仓库建立关联"><a href="#将本地仓库和远程仓库建立关联" class="headerlink" title="将本地仓库和远程仓库建立关联"></a>将本地仓库和远程仓库建立关联</h2><ol>
<li>首先在远程仓库中添加本地仓库的 SSH公钥<ul>
<li>执行 <code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></li>
<li>此时，会在用户主目录下出现 <code>.ssh</code> 目录，该目录下有 <code>id_rsa</code> （私钥）和 <code>id_rsa.pub</code> （公钥）两个文件</li>
<li>在 github 上为该电脑添加 SSH Keys，将 <code>id_rsa.pub</code> 文件中的内容拷贝到 Key 中 </li>
</ul>
</li>
<li>在远程仓库中建立一个新的 repository ，将本地仓库和远程仓库之间建立关联，执行命令：<code> git remote add origin git@github.com:Crystal1213/learngit.git</code></li>
<li>将本地仓库的内容推送到远程，执行命令 <code>git push -u origin master</code> origin 是远程库的名字，master 是当前分支，这里加了 <code>-u</code> ，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令。注：以后推送时，只需执行 <code>git push origin master</code></li>
</ol>
<h2 id="将远程仓库克隆到本地"><a href="#将远程仓库克隆到本地" class="headerlink" title="将远程仓库克隆到本地"></a>将远程仓库克隆到本地</h2><p><code>git clone 远程仓库地址</code></p>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>创建一个自己的分支，当所有工作都做完后合并到原来的分支</p>
<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><ul>
<li>查看分支：<code>git branch</code></li>
<li>创建分支：<code>git branch 分支名</code></li>
<li>切换分支：<code>git checkout 分支名</code> 或者 <code>git switch 分支名</code></li>
<li>创建并切换分支：<code>git checkout -b 分支名</code> 或者 <code>git switch -c 分支名</code></li>
<li>合并到当前分支分支：<code>git merge 分支名</code></li>
<li>删除分支：<code>git branch -d 分支名</code></li>
</ul>
<h2 id="合并分支出现冲突"><a href="#合并分支出现冲突" class="headerlink" title="合并分支出现冲突"></a>合并分支出现冲突</h2><p>手动修改出现冲突的文件，可以用命令 <code>git log --graph</code> 查看分支合并图<br><code>git log --graph --pretty=oneline --abbrev-commit</code></p>
<h2 id="合并分支时保留历史分支"><a href="#合并分支时保留历史分支" class="headerlink" title="合并分支时保留历史分支"></a>合并分支时保留历史分支</h2><p>合并分支：默认情况下是 <code>Fast Forward</code> 模式，也就是合并后，会丢掉分支信息<br>禁止使用 <code>Fast Forward</code> 模式，在合并分支时，就会生成一个新的 commit，这样就能从分支历史上看出分支信息，合并分支时执行命令 <code>git merge --no-ff -m &quot;提示信息&quot; 待合并的分支名</code></p>
<h2 id="修复其他分支的-bug-时，保存该分支的工作现场"><a href="#修复其他分支的-bug-时，保存该分支的工作现场" class="headerlink" title="修复其他分支的 bug 时，保存该分支的工作现场"></a>修复其他分支的 bug 时，保存该分支的工作现场</h2><p>保存工作现场命令：<code>git stash</code> （保存哪个分支的工作现场，就在哪个分支上执行）<br>查看已保存的工作现场：<code>git stash list</code><br>恢复工作现场：</p>
<ul>
<li><code>git stash pop</code> </li>
<li>或者 <code>git stash apply stash@&#123;数字&#125;</code> 此时 list 中还有此工作现场，需要执行 <code>git stash drop</code> 来将该工作现场删除</li>
</ul>
<p>注：如果想将其他分支修复 bug 后的结果，合并到该分支，在恢复该分支的工作现场之前，执行 <code>git cherry-pick &lt;commit&gt;</code> commit 是在执行 <code>git commit -m &quot;&quot;</code> 命令后，显示出来的那一串字母加数字，例如：<code>1d4b803</code></p>
<h2 id="删除未被合并的分支"><a href="#删除未被合并的分支" class="headerlink" title="删除未被合并的分支"></a>删除未被合并的分支</h2><p><code>git branch -D 分支名</code> 将原来小写的 d 改为大写的 D</p>
<h2 id="多人协作的步骤"><a href="#多人协作的步骤" class="headerlink" title="多人协作的步骤"></a>多人协作的步骤</h2><p>查看远程仓库的信息：<code>git remote -v</code></p>
<ol>
<li>将远程仓库克隆到本地，执行命令 <code>git clone git@github.com:Crystal1213/learngit.git</code>注意先将本地电脑的 SSH 加入到 github 中，然后再克隆；</li>
<li>创建并切换到 dev 分支，执行命令 <code>git checkout -b dev origin/dev</code> 本地分支和远程仓库的分支名最好相同，注意：这里是创建远程分支 <code>origin/dev</code> 的对应分支 <code>dev</code></li>
<li>开发完成后，在本地 commit 后，即执行 <code>git add 文件名</code> <code>git commit -m &quot;备注&quot;</code> 后，将该分支推送到远程 <code>git push origin dev</code></li>
</ol>
<p>推送到远程可能出现的问题：<br><code>your current branch is behind</code> ：表明当前的分支落后了，那么需要将远程仓库相应分支的内容 pull （pull = fetch + merge），即将远程的分支拉下来，并和本地合并。执行命令 <code>git pull</code>。如果有冲突，在本地解决冲突后，再合并。</p>
<p>执行 <code>git pull</code> 出现 <code>no tracking information for the current branch</code> ，意思是没有指定本地分支 <code>dev</code> 和 远程分支 <code>origin/dev</code> 之间的连接，执行命令 <code>git branch --set-upstream-to=origin/dev dev</code></p>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>commit 号比较难记，所以用标签来表示 commit 号。</p>
<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><ul>
<li><code>git tag 标签名</code> ：默认在 HEAD 处创建标签</li>
<li><code>git tag 标签名 commit号</code> ：在 commit 号处创建标签</li>
<li><code>git tag -a 标签名 -m “Tagger信息” commit号</code> ：在 commit 号处创建标签的同时增加该标签的一些说明信息，<code>-a</code> 指定标签名，<code>-m</code> 指定说明文字</li>
<li><code>git tag</code> ：显示所有标签，按照字母顺序排列</li>
<li><code>git show 标签名</code>：显示该标签处对应的详细信息</li>
</ul>
<h2 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h2><ul>
<li><code>git push origin 标签名</code> ：将本地标签推送到远程</li>
<li><code>git push origin --tags</code> ：将本地所有标签推送到远程</li>
<li><code>git tag -d 标签名</code> ：删除的本地标签</li>
<li><code>git push origin :refs/tags/标签名</code> ：删除远程标签，:refs/tags/标签名 这里其实是 .git 目录下对应的目录</li>
</ul>
<h1 id="参与开源项目"><a href="#参与开源项目" class="headerlink" title="参与开源项目"></a>参与开源项目</h1><p>基本步骤：</p>
<ol>
<li>将他人的开源仓库 fork 到自己的 Github 上；</li>
<li>将该开源仓库从自己的 Github 上克隆到本地；<code>git clone 项目地址</code></li>
<li>修改该项目；</li>
<li>推送一个 pull request 到他人开源仓库。（当然他人可选择接受或不接受）</li>
</ol>
<h1 id="本地仓库关联多个远程仓库"><a href="#本地仓库关联多个远程仓库" class="headerlink" title="本地仓库关联多个远程仓库"></a>本地仓库关联多个远程仓库</h1><p>以既关联 github 又关联 gitee 为例，此时已经关联了 github。</p>
<ol>
<li>创建 gitee 账号，将本地电脑的 SSH 公钥增加到 gitee 中；</li>
<li>在 gitee 中创建一个仓库（最好与本地仓库同名）；</li>
<li>将本地仓库与远程仓库建立关联，<code>git remote add gitee git@gitee.com:yanyufang/learngit.git</code> （注意：这里的 gitee 是远程仓库名，github 中对应的远程仓库名叫 origin，这也是默认的远程仓库名，这两个远程仓库名不能重名，否则会出现 <code> fatal: remote origin already exists.</code>）</li>
<li>将本地仓库推送到远程，<code>git push gitee master</code></li>
</ol>
<p>修改远程仓库名：<code>git remote rename 旧名字 新名字</code><br>删除已关联的远程仓库：<code>git remote remove 远程仓库名</code><br>显示已关联的远程仓库的信息：<code>git remote -v</code><br>修改远程仓库的地址：<code>git remote set-url 远程仓库名 新地址</code></p>
<h1 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h1><p>一些文件只在本地 git 仓库有，并不想推送到远程。<br>处理方法：</p>
<ol>
<li>建立 <code>.gitignore</code> 文件，将想要忽略的文件的写入其中；</li>
<li>将 <code>.gitignore</code> 文件提交到 git 仓库；</li>
<li>检查是否创建成功，用 <code>git status</code> 命令，是否显示 <code>working directory clean</code>。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://i.loli.net/2020/12/19/rExAoiPVfLMm18u.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 常用命令</title>
    <url>/posts/3003968415/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#1-%E5%89%8D%E8%A8%80">1 前言</a><ul>
<li><a href="#11-%E7%89%88%E6%9C%AC%E5%88%86%E7%B1%BB">1.1 版本分类</a></li>
<li><a href="#12-%E5%AE%89%E8%A3%85">1.2 安装</a></li>
<li><a href="#13-%E7%B3%BB%E7%BB%9F%E5%88%86%E5%8C%BA">1.3 系统分区</a></li>
<li><a href="#14-%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7xshell">1.4 远程登录管理工具（XShell）</a></li>
<li><a href="#15-windows-%E7%B3%BB%E7%BB%9F%E5%92%8C-linux-%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6">1.5 Windows 系统和 Linux 系统之间拷贝文件</a></li>
<li><a href="#16-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">1.6 注意事项</a></li>
</ul>
</li>
<li><a href="#2-%E7%9B%AE%E5%BD%95">2 目录</a><ul>
<li><a href="#21-linux-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">2.1 Linux 目录结构</a></li>
<li><a href="#22-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%B3%E6%9C%BA%E5%8F%8A%E9%87%8D%E5%90%AF%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">2.2 远程服务器关机及重启时的注意事项</a></li>
</ul>
</li>
<li><a href="#3-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">3 常用命令</a><ul>
<li><a href="#31-%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F">3.1 命令基本格式</a></li>
<li><a href="#32-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">3.2 目录操作命令</a><ul>
<li><a href="#ls-%E5%91%BD%E4%BB%A4">ls 命令</a></li>
<li><a href="#cd-%E5%91%BD%E4%BB%A4">cd 命令</a></li>
<li><a href="#pwd-%E5%91%BD%E4%BB%A4">pwd 命令</a></li>
<li><a href="#mkdir-%E5%91%BD%E4%BB%A4">mkdir 命令</a></li>
<li><a href="#rmdir-%E5%91%BD%E4%BB%A4">rmdir 命令</a></li>
</ul>
</li>
<li><a href="#33-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4">3.3 文件操作命令</a><ul>
<li><a href="#touch-%E5%91%BD%E4%BB%A4">touch 命令</a></li>
<li><a href="#stat-%E5%91%BD%E4%BB%A4">stat 命令</a></li>
<li><a href="#cat-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9">cat 查看文件的内容</a></li>
<li><a href="#more-%E5%88%86%E5%B1%8F%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E7%9A%84%E5%91%BD%E4%BB%A4">more 分屏显示文件的命令</a></li>
<li><a href="#less-%E5%91%BD%E4%BB%A4">less 命令</a></li>
<li><a href="#head-%E5%91%BD%E4%BB%A4">head 命令</a></li>
<li><a href="#tail-%E5%91%BD%E4%BB%A4">tail 命令</a></li>
<li><a href="#ln-%E5%91%BD%E4%BB%A4">ln 命令</a></li>
</ul>
</li>
<li><a href="#34-%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6%E9%83%BD%E8%83%BD%E6%93%8D%E4%BD%9C%E7%9A%84%E5%91%BD%E4%BB%A4">3.4 目录和文件都能操作的命令</a><ul>
<li><a href="#rm-%E5%91%BD%E4%BB%A4">rm 命令</a></li>
<li><a href="#cp-%E5%91%BD%E4%BB%A4">cp 命令</a></li>
<li><a href="#mv-%E5%91%BD%E4%BB%A4">mv 命令</a></li>
</ul>
</li>
<li><a href="#35-%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86">3.5 基本权限管理</a></li>
<li><a href="#36-%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4">3.6 帮助命令</a><ul>
<li><a href="#man-%E5%91%BD%E4%BB%A4">man 命令</a></li>
<li><a href="#info-%E5%91%BD%E4%BB%A4">info 命令</a></li>
<li><a href="#help-%E5%91%BD%E4%BB%A4">help 命令</a></li>
<li><a href="#---help-%E9%80%89%E9%A1%B9">– help 选项</a></li>
</ul>
</li>
<li><a href="#37-%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4">3.7 搜索命令</a><ul>
<li><a href="#whereis-%E5%91%BD%E4%BB%A4">whereis 命令</a></li>
<li><a href="#which-%E5%91%BD%E4%BB%A4">which 命令</a></li>
<li><a href="#locate-%E5%91%BD%E4%BB%A4">locate 命令</a></li>
<li><a href="#find-%E5%91%BD%E4%BB%A4">find 命令</a></li>
<li><a href="#grep-%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85%E5%91%BD%E4%BB%A4">grep 命令（补充命令）</a></li>
<li><a href="#%E7%AE%A1%E9%81%93%E7%AC%A6%E8%A1%A5%E5%85%85%E5%91%BD%E4%BB%A4">管道符（补充命令）</a></li>
<li><a href="#%E5%91%BD%E4%BB%A4%E7%9A%84%E5%88%AB%E5%90%8D%E8%A1%A5%E5%85%85%E5%91%BD%E4%BB%A4">命令的别名（补充命令）</a></li>
<li><a href="#%E5%BF%AB%E6%8D%B7%E9%94%AE">快捷键</a></li>
</ul>
</li>
<li><a href="#38-%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4">3.8 压缩和解压缩命令</a><ul>
<li><a href="#zip-%E6%A0%BC%E5%BC%8F">.zip 格式</a></li>
<li><a href="#gz-%E6%A0%BC%E5%BC%8F%E4%B8%8D%E4%BC%9A%E6%89%93%E5%8C%85">.gz 格式（不会打包）</a></li>
<li><a href="#bz2-%E6%A0%BC%E5%BC%8F%E4%B8%8D%E8%83%BD%E5%8E%8B%E7%BC%A9%E7%9B%AE%E5%BD%95">.bz2 格式（不能压缩目录）</a></li>
<li><a href="#tar%E5%8F%AA%E6%89%93%E5%8C%85">.tar（只打包）</a></li>
<li><a href="#targz-%E5%92%8Ctarbz2-%E6%89%93%E5%8C%85%E5%8E%8B%E7%BC%A9">.tar.gz 和.tar.bz2 （打包+压缩）</a></li>
</ul>
</li>
<li><a href="#39-%E5%85%B3%E6%9C%BA%E5%92%8C%E9%87%8D%E5%90%AF%E5%91%BD%E4%BB%A4">3.9 关机和重启命令</a><ul>
<li><a href="#sync-%E5%91%BD%E4%BB%A4">sync 命令</a></li>
<li><a href="#shutdown">shutdown</a></li>
<li><a href="#reboot-%E5%91%BD%E4%BB%A4">reboot 命令</a></li>
<li><a href="#halt-%E5%92%8C-poweroff-%E5%91%BD%E4%BB%A4">halt 和 poweroff 命令</a></li>
<li><a href="#init-%E5%91%BD%E4%BB%A4">init 命令</a></li>
</ul>
</li>
<li><a href="#310-%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4">3.10 常用网络命令</a><ul>
<li><a href="#%E9%85%8D%E7%BD%AE-ip">配置 IP</a></li>
<li><a href="#ifconfig">ifconfig</a></li>
<li><a href="#ping-%E5%91%BD%E4%BB%A4">ping 命令</a></li>
<li><a href="#netstat">netstat</a></li>
<li><a href="#wirte">wirte</a></li>
<li><a href="#wall">wall</a></li>
<li><a href="#mail">mail</a></li>
</ul>
</li>
<li><a href="#311-%E7%97%95%E8%BF%B9%E5%91%BD%E4%BB%A4">3.11 痕迹命令</a><ul>
<li><a href="#w-%E5%91%BD%E4%BB%A4">w 命令</a></li>
<li><a href="#who">who</a></li>
<li><a href="#last">last</a></li>
<li><a href="#lastlog">lastlog</a></li>
<li><a href="#lastb">lastb</a></li>
</ul>
</li>
<li><a href="#312-%E6%8C%82%E8%BD%BD%E5%91%BD%E4%BB%A4">3.12 挂载命令</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->


<p>主要讲解 Linux 相关的命令，以及 Linux 相关的知识</p>
<a id="more"></a>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><h3 id="1-1-版本分类"><a href="#1-1-版本分类" class="headerlink" title="1.1 版本分类"></a>1.1 版本分类</h3><ul>
<li>内核版 <a href="http://www.kernel.org/">www.kernel.org</a> 主要用 RHEL6.x 2.6.x、REHL7.x 3.10.x</li>
<li>发行版 （在内核版的基础上加了一些第三方软件等等）<ul>
<li>RedHat 系列 </li>
<li>个人版：Fedora </li>
<li>服务器版：RHEL（RedHat Enterprise Linux）–&gt;Centos</li>
<li>Debian系列</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/03/02/E9Vit1wP8oa7rML.png" alt="image.png"></p>
<h3 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h3><ul>
<li>虚拟机的安装：VMware</li>
<li>centos 安装：<br>官网： <a href="https://www.centos.org/download/">https://www.centos.org/download/</a></li>
</ul>
<p>设置：</p>
<ul>
<li>网络设置：（虚拟机–&gt;设置–&gt;网络适配器）<ul>
<li>桥接模式：虚拟机和本地真实网卡连接 （建议设置为该模式）。真实机器有两块网卡，无线网卡和有线网卡。如果是自动选择，网络有可能不通（因为真实机器如果此时连接的是无线网络，虚拟机连接了真实机的有线网卡，此时网络就不通了）。最好手动设置，编辑–&gt;虚拟网络编辑器。</li>
<li>NAT 模式：使用虚拟网卡 8 进行通信，虚拟网卡 8 的 ip 是自动配置的，不存在冲突的可能</li>
<li>仅主机模式：使用虚拟网卡 1 进行通信<br><img src="https://i.loli.net/2021/03/02/3LsfW1AeJKVaqUj.png" alt="image.png"></li>
</ul>
</li>
</ul>
<p>快照管理器：通过快照管理器可将系统恢复到指定的状态  </p>
<p>将当前的镜像克隆变成另外一个镜像：虚拟机–&gt;管理–&gt;克隆，</p>
<ul>
<li>克隆的时候可以选择克隆当前的状态还是快照的状态</li>
<li>选择创建链接克隆还是创建完整克隆：如果创建链接克隆，耗资源少，但是原始镜像删了，当前克隆的虚拟机也就不能用了。（推荐链接克隆，占用资源少，只要不删原始的镜像就行）</li>
</ul>
<p>系统启动：</p>
<ul>
<li>如果是安装的真实系统需要改 BIOS（基本输入输出系统）的设置，因为默认是从硬盘启动的，这里需要根据实际情况进行选择，是从光盘启动、U 盘启动还是硬盘启动等等。</li>
<li>安装的是虚拟机，就不用改了。因为它自己会自动检测，检测到硬盘是空的，就从光盘启动或者其他地方。</li>
</ul>
<p>主机名：建议修改主机名，初学时建议不要修改</p>
<p>密码三原则：</p>
<ul>
<li>复杂性：大于 8 位，大写、小写、数字、符号至少三种，不允许使用和个人身份相关的密码，不允许使用现有的英文单词</li>
<li>易记忆</li>
<li>时效性： 180 天</li>
</ul>
<p>系统安装完以后，会有一些日志文件</p>
<ul>
<li>anaconda-ks.cfg：里面记录了安装系统时的一些设置</li>
</ul>
<h3 id="1-3-系统分区"><a href="#1-3-系统分区" class="headerlink" title="1.3 系统分区"></a>1.3 系统分区</h3><p>两种分区表形式：</p>
<ul>
<li>MBR 分区表（主引导记录分区表）：最大支持 2.1T 硬盘，最多支持 4 个分区</li>
<li>GPT 分区表（全局唯一标示分区表）：支持 9.4 ZB 硬盘（1ZB = 1024 PB, 1PB = 1024 EB, 1EB = 1024 TB），理论上支持的分区数没有限制，但 Windows 限制 128 个主分区</li>
</ul>
<p>分区类型：</p>
<ul>
<li>主分区：最多只能有 4 个</li>
<li>扩展分区：最多只能有 1 个；主分区加扩展分区最多有 4 个；不能写入数据，只能包含逻辑分区</li>
<li>逻辑分区：编号从 5 开始，（编号 1，2，3，4，都给主分区和扩展分区使用）</li>
</ul>
<p>格式化：<br>格式化并不是为了清空数据，而是为了写入文件系统，附带清空数据。<br>又称为逻辑格式化，是指根据用户选定的文件系统，在磁盘的特定区域（分区）写入特定数据，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。<br>将整个分区分成两个部分，大的部分用来保存数据，这个大的部分分成一个个 block；小的部分用来存放一些索引信息。</p>
<ul>
<li>Linux 下，一个 block 默认是 4KB</li>
<li>block 不一定是连续的，但是系统尽量连续存放 </li>
<li>block 是存储数据的最小单位，一个 block 只要占用了，即使没占满也不能存放其他数据</li>
</ul>
<p>设备文件名：<br>Linux 下所有的硬件设备都有设备文件名<br>举例：<img src="https://i.loli.net/2021/03/02/aX36ltZLxHMoukw.png" alt="image.png"><br>分区设备文件名：（命名规则要看懂）<br>硬件设备（device）文件名都保存在 /dev 这个文件夹下</p>
<ul>
<li>/dev/hda1 (IDE 硬盘接口) :hd 表示接口类型，a 表示第一块硬盘，1 表示第 1 个分区</li>
<li>/dev/sda1 (SCSI 硬盘接口、SATA 硬盘接口、USB 接口) </li>
<li>/dev/sdb5：第二块 SATA 接口硬盘的第一个逻辑分区</li>
</ul>
<p>挂载点：（类似于 Windows 里面的盘符，即每个盘的名称，C 盘、D 盘等）<br>“已经存在”的“空目录”作为挂载点，挂载点是进入分区访问数据的入口。理论上所有的目录都可以作为挂载点，但是有的目录，例如 /bin/、/lib/、/etc/ 必须放在根分区下<br>挂载：将设备文件名和挂载点连起来的过程称为挂载。<br>必须分区：</p>
<ul>
<li>/ (根分区)</li>
<li>swap 分区（交换分区）内核访问的分区，普通用户无法直接访问<ul>
<li>真实内存小于 4GB，swap 为内存的两倍</li>
<li>真实内存大于 4GB，swap 和内存一致</li>
<li>实验环境，不大于 2GB</li>
</ul>
</li>
<li>推荐分区<ul>
<li>/boot (启动分区，1GB)：系统启动时需要占一定的内存，如果没有分配该分区会占用根分区的内存，当根分区的内存满了以后，系统会无法启动。所以该分区也是必须的。</li>
</ul>
</li>
<li>常用分区（根据个人需要来分区）<ul>
<li>/home(用于文件服务器)</li>
<li>/www(用于 Web 服务器)<br><img src="https://i.loli.net/2021/03/03/K56IxTDiaXVE3mn.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h3 id="1-4-远程登录管理工具（XShell）"><a href="#1-4-远程登录管理工具（XShell）" class="headerlink" title="1.4 远程登录管理工具（XShell）"></a>1.4 远程登录管理工具（XShell）</h3><p>一般使用远程登录管理工具来访问 Linux 系统，这就需要配置 Linux 的 IP 地址</p>
<ul>
<li>Centos 6 使用 <code>setup</code> 命令进行网络配置，这是 Redhat 特有的命令。</li>
<li>Centos 7 使用 <code>nmtui</code> 命令进行网络配置<ul>
<li>选择 Edit a connection 进入</li>
<li>选择接口 ens33</li>
<li>选择 &lt;Edit …&gt;</li>
<li>光标定位到 Show，回车，即可出现详细的信息</li>
<li>注意修改 Automatically connect, 按下空格键，让其显示 X</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/03/04/vGf2LxzCekUw6Ri.png" alt="image.png"></p>
<p>执行命令 <code>service network restart</code> 重启网络服务<br>执行命令 <code>ip a</code> 来查看配置好的 IP </p>
<p>桥接模式下，连接的是真实机，配置的虚拟机的 ip 要和真实机在同一个网段，但有可能出现配置的虚拟机的 ip 地址冲突。<br>NAT 模式下，连接的是虚拟网卡 8，虚拟网卡 8 是随机生成的一个网段。该模式下，设置虚拟机的网关时要设置为 … .2，可以查看下 NAT 模式下的网关（编辑–&gt;虚拟网络编辑器–&gt;NAT设置）</p>
<p>XShell 可以在 Windows 界面下用来访问远端不同系统下的服务器，从而达到远程控制终端的目的。因为在虚拟机中操作 Linux 系统需要频繁切换鼠标，缺乏个性化设置，不支持中文显示，所以使用 XShell 来连接并使用安装好的虚拟机。<br>设置好远程服务器的 ip 即可操作远程虚拟机的 Linux 系统</p>
<h3 id="1-5-Windows-系统和-Linux-系统之间拷贝文件"><a href="#1-5-Windows-系统和-Linux-系统之间拷贝文件" class="headerlink" title="1.5 Windows 系统和 Linux 系统之间拷贝文件"></a>1.5 Windows 系统和 Linux 系统之间拷贝文件</h3><p>用 WinSCP 这个工具即可，只需设置远程 Linux 系统的 ip，使用的是 SSH 协议。</p>
<p>Linux 中的文件，# 开头的是注释</p>
<h3 id="1-6-注意事项"><a href="#1-6-注意事项" class="headerlink" title="1.6 注意事项"></a>1.6 注意事项</h3><ul>
<li>Linux 中严格区分大小写</li>
<li>Linux 一些皆文件：有些操作是临时生效，系统重启后就失效了；有些操作是永久生效，原因在于在对其进行修改时写入了文件中。</li>
<li>Linux 不依赖于文件的扩展名来区分文件类型，靠权限标识来区分文件类型。因此，Linux 中并不要求文件一定要有扩展名，但是一些特殊文件还是要有扩展名的，例如：压缩包、二进制软件包（.rpm）、程序文件、网页文件。</li>
<li>Linux 中所有的硬件设备必须挂载之后才能使用（挂载：将硬件设备文件名和空目录，即挂载点，连接起来的过程）</li>
<li>Windows 下的程序不能直接在 Linux 下直接使用</li>
</ul>
<h2 id="2-目录"><a href="#2-目录" class="headerlink" title="2 目录"></a>2 目录</h2><h3 id="2-1-Linux-目录结构"><a href="#2-1-Linux-目录结构" class="headerlink" title="2.1 Linux 目录结构"></a>2.1 Linux 目录结构</h3><p>系统命令相关的目录，bin 是 binary 的缩写，sbin 中的 s 表示 super</p>
<ul>
<li>/bin/：存放系统命令的目录，普通用户和超级用户都可以执行，是 /usr/bin/ 目录的软链接。</li>
<li>/sbin/：存放系统命令的目录，只有超级用户才可以执行，是 /usr/sbin/ 目录的软链接。</li>
<li>/usr/bin/：存放系统命令的目录，普通用户和超级用户都可以执行</li>
<li>/usr/sbin/：存放系统命令的目录，只有超级用户可以执行</li>
</ul>
<hr>
<ul>
<li>/boot/：系统启动目录，保存与系统启动相关的文件</li>
<li>/dev/：保存硬件设备的设备文件</li>
<li>/etc/：配置文件保存位置。系统中所有采用默认安装方式（rpm安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等。</li>
<li>/home/：普通用户的家目录。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的家目录，所有普通用户的宿主目录是在 /home/ 下建立一个和用户名相同的的目录。如用户 user1 的家目录就是 /home/user1/</li>
</ul>
<hr>
<p>系统函数相关的目录：</p>
<ul>
<li>/lib/：系统调用的函数库保存位置，是 /usr/lib/ 的软链接</li>
<li>/lib64/：64位库函数保存位置。是 /usr/lib64/ 的软链接。文件夹中，以 .so.+数字结尾的文件都是系统中十分重要的文件，删掉后可能会导致系统崩溃。</li>
</ul>
<hr>
<ul>
<li>/lost+found/：当系统意外崩溃或者机器以外关机时，产生的一些碎片放在这里。系统启动的过程中 fsck 工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如：/lost+found 就是根分区的备份恢复目录，/boot/lost+found 就是 /boot 分区的备份恢复目录。</li>
</ul>
<hr>
<p>空目录：</p>
<ul>
<li>/media/：挂载目录。系统建议是用来挂载媒体设备的，如软件和光盘</li>
<li>/misc/：挂载目录。系统建议用来挂载 NFS 服务的共享目录</li>
<li>/mnt/：挂载目录。早期 Linux 只有这一个挂载目录，并没有细分，例如早期：/mnt/cdrom/ 挂载光盘，/mnt/usb/ 挂载 U 盘。</li>
</ul>
<hr>
<ul>
<li>/opt/：第三方安装软件的保存位置，但习惯放在 /usr/local/ 目录下。</li>
</ul>
<hr>
<p>保存在内存下的目录：不要在该目录下做实验，内存满了就会死机，内存是临时存储，重启后数据就丢失了。</p>
<ul>
<li>/net/：</li>
<li>/proc/：虚拟文件系统，该目录中的数据并不保存在硬盘上，而是保存到内存中。保存系统的内核、进程、外部设备状态和网络状态等信息。</li>
<li>/sys/：虚拟文件系统，保存内核相关的信息。</li>
</ul>
<hr>
<ul>
<li>/root/：root 的宿主目录，普通用户的宿主目录在 /home/ 下，root 宿主目录在 / 下</li>
<li>/tmp/ ：临时目录，系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入，建议该目录不能保存重要数据，最好每次开机都把该目录清空</li>
</ul>
<hr>
<p>/usr/ 相关的一些二级目录：</p>
<ul>
<li>/usr/：系统软件资源目录。usr 是 Unix Software Resource 的缩写，系统中安装的软件大多数都保存在这里</li>
<li>/usr/lib/：应用程序调用的函数库保存位置</li>
<li>/usr/local/：手动安装的软件保存的位置，建议源码保存在 /usr/local/src/ 目录中</li>
<li>/usr/src/：软件源码保存的位置，但不建议保存在这里。在该目录的 /usr/src/kernels/ 的目录下保存了大量的内核源码</li>
</ul>
<hr>
<p>/var/ 相关的一些二级目录：</p>
<ul>
<li>/var/：动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件</li>
<li>/var/www/html/：RPM 包安装的 Apache 的网页主目录</li>
<li>/var/lib/：程序运行中需要调用或改变的数据保存位置。例如：MySQL 的数据库保存在 /var/lib/mysql/ 目录中</li>
<li>/var/log/：保存系统日志</li>
<li>/var/spool/：放置队列数据的目录。就是排队等待其他程序使用的数据，例如邮件队列、打印队列</li>
<li>/var/spool/mail/：新收到的邮件队列保存位置，系统新收到的邮件会保存在此目录中</li>
<li>/var/spool/cron/：系统的定时任务队列保存位置。系统的计划任务会保存在这里。</li>
</ul>
<p>说明：可以做实验的目录：</p>
<ul>
<li>/home/：普通用户可以在该目录下</li>
<li>/root/：超级用户可以在该目录下</li>
<li>/tmp/</li>
</ul>
<h3 id="2-2-远程服务器关机及重启时的注意事项"><a href="#2-2-远程服务器关机及重启时的注意事项" class="headerlink" title="2.2 远程服务器关机及重启时的注意事项"></a>2.2 远程服务器关机及重启时的注意事项</h3><p>远程服务其不能关机，只能重启。</p>
<p>服务器重启之前，需要注意以下两点：</p>
<ul>
<li>远程服务器在重启之前，要中止正在执行的服务。（计算机硬件最怕在高速存储时断电或重启，非常容易造成硬盘的损坏）</li>
<li>重启命令的选用，最好使用 <code>shutdown -r now</code> 命令重启，这条命令在重启时会正常保存和中止服务器中正在运行的程序，是安全的重启命令。而且最好在重启之前执行几次 <code>sync</code> 命令，这是数据同步的命令，可以暂时保存在内存中的数据同步到硬盘。</li>
<li>不要在服务器运行的高峰运行高负载命令，高负载命令：赋值大量的数据、压缩或解压缩大文件，建议在凌晨 4：00-5：00 执行这些命令，可使用系统的计划任务，让操作系统自动在指定时间段执行。</li>
<li>远程配置防火墙（防火墙的基本功能：数据包过滤，可通过 IP 地址、MAC 地址、端口号、协议类型、数据包中的数据来判断）时不要把自己踢出服务器，防火墙配置完全是靠手工来完成的，配置规则和配置命令相对也比较复杂，万一设置错了，就很麻烦。<strong>建议：最好在本地的虚拟机上测试好了，再上传到远程的真实服务器；或者写一个系统定时任务，让其 5 分钟清空一下防火墙规则，就算写错了也有返回的机会，等测试没问题了在删除这个定时任务。</strong></li>
<li>指定合理的密码规范并定期更新</li>
<li>合理分配权限（给予用户最小权限）</li>
<li>定期备份重要数据和日志（原则：不要把鸡蛋放在同一个篮子里）</li>
</ul>
<h2 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3 常用命令"></a>3 常用命令</h2><h3 id="3-1-命令基本格式"><a href="#3-1-命令基本格式" class="headerlink" title="3.1 命令基本格式"></a>3.1 命令基本格式</h3><ol>
<li>命令提示符：<br><code>[root@localhost ~]#</code></li>
</ol>
<ul>
<li>root：表示当前登录的用户</li>
<li>@：没有含义，只是一个分隔符</li>
<li>localhost：当前系统的简写主机名，完整的主机名是 localhost.localdomain</li>
<li>~：代表用户当前所在的目录，该例中是家目录</li>
<li>#：命令提示符。超级用户是 #，普通用户是 $</li>
</ul>
<ol start="2">
<li>命令基本格式：<br><code>[root@localhost ~]# 命令 [选项] [参数]</code></li>
</ol>
<ul>
<li>选项：用来调整命令的功能</li>
<li>参数：指命令的操作对象，如果省略是因为有默认参数<br>以目录操作命令 ls 为例，其主要作用是显示目录下的内容。</li>
<li>命令名称：ls</li>
<li>英文原意：list</li>
<li>所在路径：/bin/ls</li>
<li>执行权限：所有用户</li>
<li>功能描述：显示目录下的内容</li>
</ul>
<p><code>ls [选项] [文件名或目录名]</code><br>选项：</p>
<ul>
<li>-a：显示当前目录的所有文件，目的是将那些隐藏的文件显示出来</li>
<li>-l：以长格式显示，会显示当前目录下内容的详细信息</li>
<li>-h：人性化显示，将当前文件的大小按照我们的习惯显示</li>
<li>-d：显示当前目录的信息，而不是当前目录下的文件的信息</li>
<li>–color=when：支持颜色输出，when 的默认值是 always（总是颜色），也可以是 never（从不显示颜色），也可以是 auto（自动）</li>
<li>-i：显示文件的 i 节点号</li>
</ul>
<p>举例：<br><img src="https://i.loli.net/2021/03/05/RnUyp8OBCs4IDhu.png" alt="image.png"></p>
<ul>
<li>第一列：权限。</li>
<li>第二列：引用计数。文件的引用计数表示该文件的硬链接的个数，目录的引用计数表示该目录下一级子目录的个数（包括隐藏的文件）</li>
<li>第三列：所有者。即该文件属于哪个用户，默认所有者是文件的建立用户。</li>
<li>第四列：所属组。默认所属组是文件建立用户的有效组，一般情况就是建立用户的所在组。</li>
<li>第五列：文件或目录的大小。</li>
<li>第六列：文件的修改时间。文件状态修改时间或文件数据修改时间都会更改这个时间，注意这里不是文件的创建时间。</li>
<li>第七列：文件名</li>
</ul>
<h3 id="3-2-目录操作命令"><a href="#3-2-目录操作命令" class="headerlink" title="3.2 目录操作命令"></a>3.2 目录操作命令</h3><h4 id="ls-命令"><a href="#ls-命令" class="headerlink" title="ls 命令"></a>ls 命令</h4><p>见上一小节内容</p>
<h4 id="cd-命令"><a href="#cd-命令" class="headerlink" title="cd 命令"></a>cd 命令</h4><ul>
<li>功能描述：切换目录的命令。</li>
<li>命令名称：cd</li>
<li>英文原意：change directory</li>
<li>所在路径：Shell 内置命令</li>
<li>执行权限：所有用户</li>
</ul>
<p>简化用法：</p>
<ul>
<li>~：表示用户的家目录</li>
<li>/：表示根目录</li>
<li>-：表示上次所在的目录</li>
<li>.：表示当前目录</li>
<li>..：表示上级目录</li>
</ul>
<p>绝对路径和相对路径：</p>
<ul>
<li>绝对路径：以根目录为参照物</li>
<li>相对路径：以当前目录为参照物</li>
</ul>
<h4 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h4><p>pwd 是 print name of current/working directory<br>功能：显示当前的目录的绝对路径</p>
<h4 id="mkdir-命令"><a href="#mkdir-命令" class="headerlink" title="mkdir 命令"></a>mkdir 命令</h4><ul>
<li>功能描述：创建命令</li>
<li>命令名称：mkdir</li>
<li>英文原意：make directories</li>
<li>所在路径：/bin/mkdir</li>
<li>执行权限：所有用户</li>
<li>选项：-p 表示递归建立所需目录，用于建立多级目录的情况</li>
<li>特别注意：只能下临时文件夹 /tmp/ 下，或者当前用户的家目录下创建目录</li>
</ul>
<h4 id="rmdir-命令"><a href="#rmdir-命令" class="headerlink" title="rmdir 命令"></a>rmdir 命令</h4><ul>
<li>命令名称：rmdir</li>
<li>英文原意：remove empty directories</li>
<li>所在路径：/bin/rmdir/</li>
<li>执行权限：所有用户</li>
<li>功能描述：删除<strong>空</strong>目录</li>
<li>选项：-p 表示递归删除目录</li>
<li>说明：rmdir 命令只能删除空目录，实际工作中常用 rm 命令来删除文件或者目录（删除目录需要使用 -r 或者 -rf，其中 -f 表示强制删除，没有一些询问信息），删除某个目录下的文件夹需要借助通配符 *，举例：<code>rm -rf /tmp/*</code></li>
<li>特别注意：Linux 系统中没有回收站的说法，文件或目录一旦删除就无法找回，建议装系统时安装 extundelete 工具，实现文件或文件夹数据的恢复</li>
</ul>
<h3 id="3-3-文件操作命令"><a href="#3-3-文件操作命令" class="headerlink" title="3.3 文件操作命令"></a>3.3 文件操作命令</h3><p>在文件中添加内容，可用 <code>echo</code>+ 内容 + <code>&gt;&gt;</code>（重定向）。</p>
<ul>
<li>echo 内容：是将内容输出到屏幕</li>
<li>“&gt;&gt;” 文件名：重定向，其作用是将显示的内容重定向到指定的文件中，追加在原有内容的末尾</li>
</ul>
<h4 id="touch-命令"><a href="#touch-命令" class="headerlink" title="touch 命令"></a>touch 命令</h4><p>创建空文件或者修改文件时间</p>
<ul>
<li>命令名称：touch</li>
<li>英文原意：change file timestamps</li>
<li>所在路径：/bin/touch</li>
<li>功能权限：所有用户</li>
<li>功能描述：修改文件的时间戳。（如果没有该文件，则新建；如果有该文件，则修改的是该文件的额时间戳）</li>
</ul>
<h4 id="stat-命令"><a href="#stat-命令" class="headerlink" title="stat 命令"></a>stat 命令</h4><p>查看文件的详细信息，包括文件的最近访问时间、最近更改时间（数据修改时间）、最近改动时间（状态修改时间）。</p>
<ul>
<li>命令名称：stat</li>
<li>英文原意：display file or file system status</li>
<li>所在路径：/usr/bin/stat</li>
<li>执行权限：所有用户<br><img src="https://i.loli.net/2021/03/05/JromPEXKF3gt5Gd.png" alt="image.png"></li>
</ul>
<h4 id="cat-查看文件的内容"><a href="#cat-查看文件的内容" class="headerlink" title="cat 查看文件的内容"></a>cat 查看文件的内容</h4><ul>
<li>命令名称：cat</li>
<li>英文原意：concatenate files and print on the standard output</li>
<li>所在路径：/bin/cat</li>
<li>执行权限：所有用户</li>
<li>选项：-A 用于列出所有的隐藏符号（回车符：$，Tab 键：^T）；-n 显示行号</li>
</ul>
<h4 id="more-分屏显示文件的命令"><a href="#more-分屏显示文件的命令" class="headerlink" title="more 分屏显示文件的命令"></a>more 分屏显示文件的命令</h4><ul>
<li>命令名称：more</li>
<li>英文原意：file persual filter for crt viewin</li>
<li>所在路径：/bin/more</li>
<li>执行权限：所有用户</li>
<li>功能描述：分屏像是文件内容</li>
</ul>
<p>该命令不用什么选项，会用到一些交互命令：</p>
<ul>
<li>空格：向下翻页</li>
<li>b：向上翻页</li>
<li>回车：一行一行的翻页</li>
<li>/字符串：查找指定的字符串</li>
<li>q：退出</li>
</ul>
<h4 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h4><p>和 more 命令类似，只是 more 是分屏显示，less 是分行显示</p>
<ul>
<li>命令名：less</li>
<li>英文原意：opposite of more</li>
<li>所在路径：/usr/bin/less</li>
<li>执行权限：所有用户</li>
<li>功能描述：分行显示</li>
</ul>
<h4 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h4><ul>
<li>英文原意：output the first part of files</li>
<li>功能描述：显示文件开头的内容</li>
</ul>
<h4 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h4><ul>
<li>英文原意：output the last part of files</li>
<li>功能描述：显示文件尾的内容</li>
<li>选项：<code>-n 行数</code> 或者 <code>-行数</code> 指定显示的行数，在 head 命令中也有该选项；<code>-f</code> 监听文件的新增内容 </li>
</ul>
<h4 id="ln-命令"><a href="#ln-命令" class="headerlink" title="ln 命令"></a>ln 命令</h4><ul>
<li>英文原意：make links between file</li>
<li>功能描述：在文件之间建立链接<br>该命令的基本格式：<code>ln [选项] 源文件 目标文件</code><br>选项：</li>
<li>-s：表示建立软链接，不加该选项表示增加的是硬链接</li>
<li>-f：强制。如果该文件已经存在，则删除目标文件后再建立链接文件</li>
</ul>
<p>硬链接的特征：（相当于两个指针指向了同一个文件）</p>
<ul>
<li>源文件和硬链接文件拥有相同的 Innode 和 Block</li>
<li>修改任意一个文件，另一个都会改变</li>
<li>删除任意一个文件，另一个都能使用</li>
<li>硬链接标记不清，很难确认硬链接文件位置，不建议使用</li>
<li>硬链接不能链接目录</li>
<li>硬链接不能跨分区</li>
</ul>
<p>软链接特征：（相当于 Windows 下的桌面上的快捷方式）</p>
<ul>
<li>软链接和源文件拥有不同的 Inode 和 Block</li>
<li>两个文件修改任意一个，另一个都改变</li>
<li>删除软链接，源文件不受影响；删除源文件，软链接不能使用</li>
<li>软链接没有实际的数据，只保留源文件的 Inode，不论源文件多大，软链接的大小不变</li>
<li>软链接是最大权限 lrwxrwxrwx.，但是由于没有实际的数据，最终个访问时需要参考源文件权限</li>
<li>软链接可以链接目录软链接可以跨分区</li>
<li>软链接特征明显，建议使用软链接</li>
<li>特别注意：软链接时，源文件一定要写<strong>绝对路径</strong>，写相对路径会导致软链接不知道和哪个文件建立</li>
</ul>
<h3 id="3-4-目录和文件都能操作的命令"><a href="#3-4-目录和文件都能操作的命令" class="headerlink" title="3.4 目录和文件都能操作的命令"></a>3.4 目录和文件都能操作的命令</h3><h4 id="rm-命令"><a href="#rm-命令" class="headerlink" title="rm 命令"></a>rm 命令</h4><p>既可以删除文件，又可以删除目录。</p>
<ul>
<li>英文原意：remove files or directories</li>
<li>选项：-f 强制删除；-i 交互删除（默认情况下就是交互删除）；-r 递归删除。通常使用的形式：<code>rm -rf 文件名或目录名</code></li>
</ul>
<h4 id="cp-命令"><a href="#cp-命令" class="headerlink" title="cp 命令"></a>cp 命令</h4><ul>
<li>英文原意：copy files and directories</li>
<li>功能描述：复制文件和目录</li>
<li>使用格式：<code>cp [选项] 源文件 目标文件</code></li>
<li>选项：-a 源文件和目标文件一模一样，包括时间、属性等信息；-r 递归复制，用于复制目录</li>
</ul>
<h4 id="mv-命令"><a href="#mv-命令" class="headerlink" title="mv 命令"></a>mv 命令</h4><ul>
<li>英文原意：move(rename) files</li>
<li>功能：移动文件或改名</li>
<li>命令格式：<code>mv [选项] 源文件 目标文件</code></li>
<li>选项：-f 强制覆盖；-i 交互移动（默认情况）；-v 显示详细信息</li>
</ul>
<h3 id="3-5-基本权限管理"><a href="#3-5-基本权限管理" class="headerlink" title="3.5 基本权限管理"></a>3.5 基本权限管理</h3><p><img src="https://i.loli.net/2021/03/05/aCAUfSrdteuh1sy.png" alt="image.png"></p>
<p>权限一共有 10 位</p>
<p>第一位：表示文件的类型</p>
<ul>
<li>d：目录文件</li>
<li>l：软链接文件</li>
<li>-：普通文件</li>
</ul>
<p>2-4 位：user，所有者（u）<br>5-7 位：group，所属组（g）<br>8-10 位：other，其他人（o）</p>
<p>rwx:</p>
<ul>
<li>r(4)：read</li>
<li>w(2)：write</li>
<li>x(1)：excute</li>
</ul>
<hr>
<p>修改文件的权限：chmod 命令</p>
<ul>
<li>英文原意：change file mode bits</li>
<li>使用格式：<code>chmod [选项] 权限模式 文件名</code></li>
<li>选项：-R 递归设置权限</li>
</ul>
<p>常用权限：<br>特别注意：一般权限对应的数字遵循（所有者 &gt;= 所属组 &gt;= 其他人）</p>
<ul>
<li>644：rw-r–r– 这是文件的基本权限，表示所有者拥有读、写权限，所属组和其他人拥有只读权限</li>
<li>755：rwxr-xr-x 这是文件的执行权限和目录的基本权限，代表所有者拥有读、写和执行权限，所属组和其他人拥有读和执行权限</li>
<li>777：rwxrwxrwx 实际使用服务器时尽量避免给目录或者文件赋予这样的权限，会造成一定的安全隐患</li>
</ul>
<p>修改文件的所有者和所属组：chown 命令</p>
<ul>
<li>英文原意：change file owner and group</li>
<li>格式：<code>chown [选项] 所有者：所属组 文件或目录</code></li>
<li>选项：-R 递归设置权限</li>
<li>注意：普通用户不能修改文件的所有者，哪怕自己是这个文件的所有者也不行；普通用户可以修改所有者是自己的文件的权限</li>
</ul>
<p>修改文件的所属组：chgrp</p>
<ul>
<li>英文原意：change group ownership</li>
</ul>
<hr>
<p>权限对文件的作用：</p>
<ul>
<li>读（r）：代表可以读取文件中的数据，可以对文件执行 cat、more、less、head、tail 等文件查看命令</li>
<li>写（w）：代表可以修改文件中的数据，但没有删除该文件的权限，可以对文件执行 vim、echo 等。如果想删除该文件，需要对文件袋额上级目录拥有写权限。</li>
<li>执行（x）：代表文件拥有执行权限，可以运行。但是文件是否能执行，取决于文件中的代码是不是正确的语言代码。对于文件来说，执行（x）权限是最高权限。</li>
</ul>
<p>权限对目录的作用：</p>
<ul>
<li>读（r）：代表可以查看目录下的内容，查看目录下有哪些子文件和子目录，可以在目录下执行 ls 命令</li>
<li>写（w）：代表可以修改目录下的数据，可以在目录中新建、删除、复制、剪切子文件或子目录，可以在目录下执行 touch、rm、cp、mv 命令。对目录来说，写（w）权限是最高权限。</li>
<li>执行（x）：目录是不能执行的，对目录有执行权限，代表可以进入目录，对目录执行 cd 命令。</li>
</ul>
<p>目录的可用权限：</p>
<ul>
<li>0：任何权限都没有</li>
<li>5：基本的目录浏览和进入权限</li>
<li>7：所有权限</li>
</ul>
<hr>
<p>umask 默认权限</p>
<ul>
<li>umask 命令查看系统的默认权限，以八进制数值的形式显示</li>
<li>umask -S 以字母的形式显示默认权限</li>
</ul>
<p>新建文件和目录的默认最大权限</p>
<ul>
<li>对于文件来讲，默认的最大权限是 666，没有执行（x）权限</li>
<li>对于目录来讲，默认的最大权限是 777，有执行（x）权限，因为对于目录来讲，执行权限仅意味着能进入该目录。</li>
</ul>
<p>umask 显示的默认权限的计算方法，以 022 (—–w–w-)为例，注意不看第一位：</p>
<ul>
<li>文件的默认最大权限是 666，对应 -rw-rw-rw-，其减去(022) —–w–w-，得到 -rw-r–r–，这就是新建文件的默认权限</li>
<li>目录的默认最大权限是 777，对应 -rwxrwxrwx，其减去(022) d—-w–w-，得到 drwxr-xr-x，这就是新建目录的默认权限</li>
</ul>
<p>修改默认权限的命令：</p>
<ul>
<li>临时修改：umask + 3 位数值</li>
<li>永久修改：需要写入配置文件 /etc/profile，该配置文件存放的是环境变量</li>
</ul>
<h3 id="3-6-帮助命令"><a href="#3-6-帮助命令" class="headerlink" title="3.6 帮助命令"></a>3.6 帮助命令</h3><h4 id="man-命令"><a href="#man-命令" class="headerlink" title="man 命令"></a>man 命令</h4><ul>
<li>英文原意：format and display the online manual pages</li>
<li>功能描述：显示联机帮助手册</li>
<li>格式：<code>man [选项] 命令</code></li>
<li>选项：<code>man -f 命令</code> 或 <code>whatis</code> 命令 查看命令拥有哪个级别的帮助。（注：命令是有级别的，<code>whatis</code> 查看命令拥有哪些级别，<code>whereis</code> 查看命令的所在位置，<code>whoami</code> 查看当前用户）</li>
<li>快捷键：<ul>
<li>上箭头 向上移动一行</li>
<li>下箭头 向下移动一行</li>
<li>g 移动到第一页</li>
<li>G 移动到最后一页</li>
<li>q 退出</li>
<li>/字符串 从当前页向下搜索字符串</li>
<li>n 搜索字符串时，使用 n 键找到下一个字符串</li>
</ul>
</li>
</ul>
<h4 id="info-命令"><a href="#info-命令" class="headerlink" title="info 命令"></a>info 命令</h4><p>一套完整的资料，每个单独命令的帮助信息只是这套完整资料中的某一小章节<br>快捷键：</p>
<ul>
<li>u：上一层信息</li>
<li>n：下一小节信息</li>
<li>p：上一小节信息</li>
</ul>
<h4 id="help-命令"><a href="#help-命令" class="headerlink" title="help 命令"></a>help 命令</h4><p>只能获取 Shell 内置命令的帮助。（Shell 是 Linux 的命令解释器）<br>可以用 type 命令来确定当前命令是内置命令还是外部命令</p>
<h4 id="–-help-选项"><a href="#–-help-选项" class="headerlink" title="– help 选项"></a>– help 选项</h4><p>命令 + - -help 来查看当前命令的帮助</p>
<h3 id="3-7-搜索命令"><a href="#3-7-搜索命令" class="headerlink" title="3.7 搜索命令"></a>3.7 搜索命令</h3><h4 id="whereis-命令"><a href="#whereis-命令" class="headerlink" title="whereis 命令"></a>whereis 命令</h4><p>搜索命令的命令，不能搜索普通文件<br>显示出该命令的源文件、帮助文件的所在路径</p>
<h4 id="which-命令"><a href="#which-命令" class="headerlink" title="which 命令"></a>which 命令</h4><p>只能查命令，不能搜索文件<br>显示出该文件的所在路径，如果有别名会显示出别名的位置</p>
<h4 id="locate-命令"><a href="#locate-命令" class="headerlink" title="locate 命令"></a>locate 命令</h4><p>按照文件名搜索普通文件的命令</p>
<ul>
<li>优点：搜索速度快，按照数据库搜索，数据库的位置 /var/lib/mlocate/mlocate.db （注意：当新建了文件之后，可能搜不到该文件，此时需要更新下数据库，执行命令 <code>updatedb</code>）</li>
<li>缺点：不能按照时间、权限等来搜索文件</li>
</ul>
<h4 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h4><ul>
<li>英文原意：search for files in a directory hierarchy</li>
<li>功能描述：在目录中搜索文件</li>
</ul>
<p>按照文件名搜索：</p>
<ul>
<li>格式：find 搜索路径 -name 文件名</li>
<li>选项：-name 按照文件名搜索；-iname 按照文件名搜索，不区分文件名的大小写；-inum 按照 inode 号搜索</li>
</ul>
<p>按照文件大小搜索：</p>
<ul>
<li>格式：find 搜索路径 -size [+/-大小] </li>
<li>选项：+ 表示搜索比指定大小还要大的文件；- 表示搜索比指定大小还要小的文件</li>
<li>注意：这里要注意下文件大小的单位，可借助 <code>man find</code> 命令查看</li>
</ul>
<p>按照时间搜索：<br>时间分为访问时间（atime）、数据修改时间内（mtime）、状态修改时间（ctime），这里的时间是以天为单位。</p>
<ul>
<li>格式：find 搜索路径 -atime [+/-]天数</li>
<li>说明：+5 代表 6 天前修改的文件；5 代表 5~6 天那一天修改的文件；-5 代表 5 天内修改的文件</li>
</ul>
<p>按照权限搜索：</p>
<ul>
<li>格式：find 搜索路径 -perm [+/-]权限值</li>
<li>说明：权限值 表示刚好等于该权限值的文件；-权限值 表示全部包含权限值的文件；+权限值 表示只要包含任意一个权限的文件</li>
</ul>
<p>按照所有者搜索：</p>
<ul>
<li>格式：find 搜索路径 [选项] 名字</li>
<li>选项：-user 按照用户名搜索；-group 按照所属组搜索；-nouser 查找没有所有者的文件</li>
<li>说明：-nouser 比较常用，通常用来查找垃圾文件，因为 Linux 中一般文件都有所有者除非是光盘或者 U 盘中的文件，要不就是手工源码包安装的文件</li>
</ul>
<p>按照文件类型搜索：</p>
<ul>
<li>格式：find 搜索路径 -type [d/f/l]</li>
<li>选项：d 查找目录；f 查找普通文件；l 查找软链接文件</li>
</ul>
<p>逻辑运算符：<br>find 在按条件进行搜索时，搜索的条件可以用逻辑运算符连接两个个条件。</p>
<ul>
<li>-a 表示逻辑与（and），意味着两个条件必须同时成立</li>
<li>-o 表示逻辑或（or），意味着只要其中一个条件成立即可</li>
<li>-not 表示逻辑非（not），意味着对当前条件取反</li>
</ul>
<p>-exec 选项和 -ok 选项：</p>
<ul>
<li>格式：find 搜索路径 [选项] 搜索内容 -exec 命令2 {} ;</li>
<li>说明：表示对 find 命令搜索的结果执行命令2；{} 就表示 find 命令搜索的结果</li>
<li>注意：使用 exec 命令时，最后一定要加上 ;</li>
<li>-ok 命令和 -exec 命令的作用差不多，只不过在执行命令 2 的过程中，会进行询问。</li>
</ul>
<h4 id="grep-命令（补充命令）"><a href="#grep-命令（补充命令）" class="headerlink" title="grep 命令（补充命令）"></a>grep 命令（补充命令）</h4><ul>
<li>作用：在文件中提取和匹配符合条件的字符串行</li>
<li>格式：grep [选项] “搜索内容” 文件名</li>
<li>选项：-i 表示忽略大小写；-n 表示输出行号；-v 表示反向查找（即查找不符合该搜索内容）；–color=auto 表示搜出的关键字用颜色显示</li>
</ul>
<p>对比：find 命令和 grep 命令</p>
<ul>
<li>find：用于在系统中搜索符合条件的文件名；是完全匹配；如果要模糊查询，则用通配符进行匹配</li>
<li>grep：用于在文件中搜索符合条件的字符串；是包含匹配；如果要模糊查询，则用正则表达式进行匹配</li>
</ul>
<p>通配符和正则表达式的区别：<br>通配符：（完全匹配）</p>
<ul>
<li>?：表示匹配任意一个字符</li>
<li>*：表示匹配 0 个或任意多个任意字符，即可以匹配任意内容</li>
<li>[]：匹配括号中任意一个字符</li>
<li>[-]：表示匹配括号中任意一个字符，- 表示一个范围，例如：[a-z]表示匹配任意一个小写字母，[A-Za-z]表示匹配任意一个字母</li>
<li>[^]：逻辑非，表示匹配不是括号中的内容，例如：[^0-9]表示匹配不是数字的字符串</li>
</ul>
<p>正则表达式：（包含匹配）</p>
<ul>
<li>?：表示匹配前一个字符重复 0 次，或 1 次（?是扩展正则，需要使用 egrep 命令）</li>
<li>*：表示匹配前一个字符 0 次或任意多次</li>
<li>[]：表示匹配括号中的任意一个字符</li>
<li>[-]：表示匹配括号中的任意一个字符，- 表示范围</li>
<li>[^]：逻辑非，表示不是括号内的一个字符</li>
<li>^：匹配行首</li>
<li>$：匹配行尾</li>
</ul>
<h4 id="管道符（补充命令）"><a href="#管道符（补充命令）" class="headerlink" title="管道符（补充命令）"></a>管道符（补充命令）</h4><ul>
<li>格式：命令1 | 命令2</li>
<li>含义：命令 1 的输出作为命令 2 的操作对象，这里操作的是文本流，相当于将命令 1 的结果暂存在一个文件中，对该文件执行命令 2 </li>
<li>说明：管道符类似于 find 命令中的 -exec，因为 find 命令无法操作文本流，也就是说不能使用管道符，所以有了 -exec 选项</li>
<li>举例：<ul>
<li>例 1：<code>ll -a /etc/ | more</code> 将 /etc/ 文件夹下的内容分屏显示</li>
<li>例 2：<code>ll -a /etc/ | grep yum</code> 查询 /etc/ 目录下含有 yum 的文件或目录</li>
<li>例 3：<code>netstat [选项]</code> 该命令用于查询网络状态</li>
<li>选项：-a 列出所有的网络状态；-t 显示出使用 TCP 协议端口的连接状况；-u 显示出 UDP 协议端口的连接状况；-n 使用 IP 地址和端口号显示，不适用域名和服务器名；-l 仅显示监听状态的连接<ul>
<li>例子 1：<code>netstat -an | grep &quot;ESTABLISHED&quot; | wc -l</code> 以 IP 地址和端口号的形式显示当前的网络状态，并基于此查询出含有 ESTABLISHED 的有多少行（wc 命令用来计数统计，-l 表示查询多少行）。即查询具体网络连接数量</li>
<li>例子 2：<code>netstat -tuln | grep 80</code> 显示含有 80 的连接信息，一般 80 就是指的端口号</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="命令的别名（补充命令）"><a href="#命令的别名（补充命令）" class="headerlink" title="命令的别名（补充命令）"></a>命令的别名（补充命令）</h4><ul>
<li>格式：<code>alias</code> 查询命令的别名；<code>alias 别名=&#39;原名令名&#39;</code> 设定命令的别名</li>
<li>说明：如果设定命令的别名，想让其永久生效就要写入环境变量配置文件中 ~/.bashrc</li>
</ul>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><ul>
<li>Tab 键：命令或文件补全</li>
<li>ctrl + U：从光标位置删除或剪切到行首</li>
<li>ctrl + Y：粘贴 ctrl + U 剪切的内容</li>
<li>ctrl + L：清屏 </li>
<li>ctrl + A：把光标移到命令行的开头</li>
<li>ctrl + E：把光标移到命令行的结尾</li>
<li>ctrl + C：强制终止当前命令</li>
</ul>
<h3 id="3-8-压缩和解压缩命令"><a href="#3-8-压缩和解压缩命令" class="headerlink" title="3.8 压缩和解压缩命令"></a>3.8 压缩和解压缩命令</h3><p>Linux 中，常见的压缩格式：.zip, .gz, .bz2, .tar, .tar.gz, .tar.bz2</p>
<h4 id="zip-格式"><a href="#zip-格式" class="headerlink" title=".zip 格式"></a>.zip 格式</h4><ul>
<li>压缩命令：<code>zip 压缩文件名.zip 需要压缩的文件（可以有多个，用空格分开即可）</code></li>
<li>解压命令：<code>unzip [-d 文件位置] 解压文件名</code></li>
</ul>
<h4 id="gz-格式（不会打包）"><a href="#gz-格式（不会打包）" class="headerlink" title=".gz 格式（不会打包）"></a>.gz 格式（不会打包）</h4><ul>
<li>压缩命令：gzip [选项] 源文件</li>
<li>选项：-c 将压缩数据输出到标准输出中，可以用于保留源文件；-d 解压缩；-r 压缩目录</li>
<li>解压缩：建议直接用上述的 -d 选项；或者用命令 <code>gunzip 文件名</code></li>
<li>注意：gzip 在压缩目录时，并不是将这个目录压缩，而是将该目录下的文件夹依次压缩；在压缩时，不用指明压缩成的文件名，而是会使用源文件名来命名，源文件名会被压缩文件替换掉</li>
</ul>
<h4 id="bz2-格式（不能压缩目录）"><a href="#bz2-格式（不能压缩目录）" class="headerlink" title=".bz2 格式（不能压缩目录）"></a>.bz2 格式（不能压缩目录）</h4><p>.bz2 格式的压缩算法更先进、压缩比更好；而 .gz 格式的压缩时间更快</p>
<ul>
<li>压缩命令：bzip2 [选项] 源文件</li>
<li>选项：-d 解压缩；-k 压缩时保留源文件；-v 显示压缩的详细信息</li>
<li>解压缩：建议用 -d 选项；或者命令 bunzip2 压缩文件名</li>
</ul>
<h4 id="tar（只打包）"><a href="#tar（只打包）" class="headerlink" title=".tar（只打包）"></a>.tar（只打包）</h4><p>只打包不会压缩</p>
<ul>
<li>命令格式：tar [选项] 源文件或目录</li>
<li>选项：-c 打包；-f 指定压缩包的文件名（特别注意压缩包文件的扩展名一定要写对）；-v 显示打包过程。（-cvf 这三个选项经常一起使用）</li>
</ul>
<p>解包：</p>
<ul>
<li>格式：tar [选项] 压缩包</li>
<li>选项：-x 解打包；-t 测试，不解打包，只是查看压缩包中有哪些文件</li>
</ul>
<h4 id="tar-gz-和-tar-bz2-（打包-压缩）"><a href="#tar-gz-和-tar-bz2-（打包-压缩）" class="headerlink" title=".tar.gz 和.tar.bz2 （打包+压缩）"></a>.tar.gz 和.tar.bz2 （打包+压缩）</h4><ul>
<li>格式：tar [选项] 压缩包 源文件或目录</li>
<li>选项：-z 压缩和解压缩 .tar.gz 格式；-j 压缩和解压缩 .tar.bz2 格式</li>
<li>压缩打包选项常用组成：-zcvf 压缩打包 .tar.gz 格式；-jcvf -j 压缩打包 .tar.bz2 格式</li>
<li>解压缩和解打包选项组成：-zxvf 解压缩解打包 .tar.gz 格式；-jxvf -j 解压缩解打包 .tar.bz2 格式</li>
<li>查看压缩包中的文件名选项组成：-ztvf 查看 .tar.gz 格式压缩包，-jtvf 查看.tar.bz2 格式压缩包</li>
<li>解压到指定位置需要在上述命令的最后加上：-C 路径名（特别注意：这里只能加在上述命令的最后，不能调换顺序）。举例：<code>tar -zxvf abc.tar.gz -C /tmp</code></li>
<li>解压压缩包中的特定文件到指定路径：<code>tar -zxvf 压缩包名 -C 路径名 特定文件名</code>，例如：<code>tar -zxvf abc.tar.gz -C /tmp /abc/123 </code> 。执行该命令前可用 -ztvf 查看下当前压缩包中有哪些文件</li>
</ul>
<h3 id="3-9-关机和重启命令"><a href="#3-9-关机和重启命令" class="headerlink" title="3.9 关机和重启命令"></a>3.9 关机和重启命令</h3><h4 id="sync-命令"><a href="#sync-命令" class="headerlink" title="sync 命令"></a>sync 命令</h4><ul>
<li>英文原意：flush file system buffers</li>
<li>功能描述：刷新文件系统缓冲区</li>
</ul>
<h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><ul>
<li>格式：shutdown [选项] 时间 [警告信息]</li>
<li>选项：-h 关机；-r 重启</li>
<li>功能描述：关机和重启</li>
</ul>
<h4 id="reboot-命令"><a href="#reboot-命令" class="headerlink" title="reboot 命令"></a>reboot 命令</h4><ul>
<li>功能描述：重启命令，没有过多的选项</li>
</ul>
<h4 id="halt-和-poweroff-命令"><a href="#halt-和-poweroff-命令" class="headerlink" title="halt 和 poweroff 命令"></a>halt 和 poweroff 命令</h4><ul>
<li>功能描述：两个命令都是关机命令，但不建议使用，因为这两个命令不会完整关闭和保存系统的服务。</li>
</ul>
<h4 id="init-命令"><a href="#init-命令" class="headerlink" title="init 命令"></a>init 命令</h4><ul>
<li>功能描述：修改 Linux 运行级别的命令，可以用于关机和重启，但不建议使用</li>
<li>关机：<code>init 0</code> (调用系统的 0 级别)</li>
<li>重启：<code>init 6</code> (调用系统的 6 级别)</li>
</ul>
<h3 id="3-10-常用网络命令"><a href="#3-10-常用网络命令" class="headerlink" title="3.10 常用网络命令"></a>3.10 常用网络命令</h3><h4 id="配置-IP"><a href="#配置-IP" class="headerlink" title="配置 IP"></a>配置 IP</h4><p>配置 IP 的方法：</p>
<ul>
<li>setup 工具</li>
<li>vi /etc/sysconfig/network-scripts/ifcfg-eth0 手工修改配置文件</li>
</ul>
<p>步骤：</p>
<ul>
<li>配置完 IP，需要重启网络服务，执行命令 <code>service network restart</code></li>
<li>虚拟机需要桥接到有线网卡，并重启网络服务</li>
<li>复制镜像有可能需要重置 UUID(唯一识别符)，这种情况在重启时会出现重启失败。需要执行以下操作<ul>
<li>vi /etc/sysconfig/network-scripts/ifcfg-eth0  删除 MAC 地址行</li>
<li>rm -rf /etc/udev/rules.d/70-persistent-net.rules 删除 MAC 地址和 UUID 绑定文件</li>
<li>reboot 重启 Linux 系统</li>
</ul>
</li>
</ul>
<h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><ul>
<li>功能描述：查看网络信息</li>
</ul>
<p><img src="https://i.loli.net/2021/03/08/gGJq1hKDyQx2pdb.png" alt="image.png"></p>
<h4 id="ping-命令"><a href="#ping-命令" class="headerlink" title="ping 命令"></a>ping 命令</h4><ul>
<li>功能描述：探测和对方的网通不通</li>
<li>英文原意：send ICMP ECHO_REQUEST to network hosts （使用 ICMP 协议进行网络探测）</li>
<li>格式：ping [选项] IP</li>
<li>选项：-b 后面加入广播地址，用于对整个网段进行探测；-c 次数 用于指定 ping 的次数；</li>
</ul>
<h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><ul>
<li>功能描述：查看网络状态</li>
<li>格式：netstat [选项]</li>
<li>选项：-a 列出所有网络状态；-n 使用 IP地址和端口号显示，不使用域名与服务名；-p 显示 PID 和程序名；-r 显示路由表；-t 显示使用 TCP 协议端口的连接状况；-u 显示使用 UDP 协议端口的连接状况；-r 显示路由表；-l 仅显示监听状态的连接</li>
<li>常用选项组合：</li>
<li>查看本机开启的端口：-tuln 查看本机开启的端口</li>
<li>查看有哪些程序开启的端口：使用 -p 选项，即 -tulnp</li>
<li>查看所有连接：-an</li>
<li>查看网关：使用 -r 查看路由表的选项，即 -rn，最后一行或者第一行就是网关信息</li>
</ul>
<h4 id="wirte"><a href="#wirte" class="headerlink" title="wirte"></a>wirte</h4><ul>
<li>功能描述：用于连接同一台服务器的不同终端之间通信</li>
<li>格式：write 用户名(USER) 终端号(TTY)</li>
<li>终端号：<ul>
<li>本地字符终端 tty1-6 alt+F1-6(在不同终端之间切换)</li>
<li>本地图形终端 tty7 ctrl+alt+F7(按住 3 秒，需要安装启动图形界面)</li>
<li>远程终端 pts/0-255</li>
</ul>
</li>
<li>查询用户名、终端号的命令：w （该命令是查看当前有多少用户登录）</li>
<li>发送信息快捷键：ctrl + D</li>
</ul>
<h4 id="wall"><a href="#wall" class="headerlink" title="wall"></a>wall</h4><ul>
<li>功能描述：给所有用户发送信息</li>
<li>格式：wall + 发送的信息</li>
</ul>
<h4 id="mail"><a href="#mail" class="headerlink" title="mail"></a>mail</h4><ul>
<li>功能描述：邮件客户端命令，该命令可以给其他永和发邮件</li>
<li>格式：mail 用户名 （回车后输入邮件主题、内容）</li>
<li>接收邮件：输入 mail 可进行接收邮件</li>
<li>查看邮件快捷键：h 命令 列出邮件列表（N 表示未读邮件）；q 命令 退出；邮件编号 可查看该邮件内容</li>
<li>邮件保存的位置：/var/spool/mail/user1(用户名)</li>
<li>常用形式：将文件已邮件的形式发送 <code>mail -s 邮件标题 用户名 &lt; 文件路径</code> </li>
</ul>
<h3 id="3-11-痕迹命令"><a href="#3-11-痕迹命令" class="headerlink" title="3.11 痕迹命令"></a>3.11 痕迹命令</h3><p>系统中有一些重要的痕迹日志文件，例如：/var/log/wtmp、/var/run/utmp、/var/log/btmp、/var/log/lastlog 等，如果用 vim 打开就是二进制乱码，需要用相应的命令来查看。</p>
<h4 id="w-命令"><a href="#w-命令" class="headerlink" title="w 命令"></a>w 命令</h4><ul>
<li>查询文件：/var/run/utmp</li>
<li>格式：w<br><img src="https://i.loli.net/2021/03/08/ab7VKQkEH5Fni2N.png" alt="image.png"></li>
<li>第一行信息的含义：<ul>
<li>11：24：43 系统当前时间</li>
<li>1：58 系统的运行时间</li>
<li>5 users 系统当前用户数量</li>
<li>load average:0.00,0.01,0.05 系统在1分钟，5分钟，15分钟的平均负载，如果 CPU 是单核的，这个数超过1就是高负载，如果 CPU 是 4 核的，超过 4 就是高负载</li>
</ul>
</li>
<li>下面的信息：<ul>
<li>USER 表示当前用户</li>
<li>TTY 表示终端号</li>
<li>WHAT 用户正在进行的操作，用来辨识哪一个是自己（标识为 w 的）</li>
</ul>
</li>
</ul>
<h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><ul>
<li>查询的文件：/var/run/utmp</li>
<li>功能描述：用于查看正在登录的用户，包括用户名、终端号、登录的时间</li>
</ul>
<h4 id="last"><a href="#last" class="headerlink" title="last"></a>last</h4><ul>
<li>查询的文件：/var/log/wtmp</li>
<li>功能描述：查看系统所有登录过的用户信息。包括正在登录的用户和之前登录的用户</li>
</ul>
<h4 id="lastlog"><a href="#lastlog" class="headerlink" title="lastlog"></a>lastlog</h4><ul>
<li>查询文件：/var/log/lastlog</li>
<li>功能描述：查看系统中所有用户最后一次登录的时间，会显示出该系统的所有用户，包括一些伪用户（用来启动服务的用户）</li>
</ul>
<h4 id="lastb"><a href="#lastb" class="headerlink" title="lastb"></a>lastb</h4><ul>
<li>查看文件：/var/log/btmp</li>
<li>功能描述：查看错误登录的用户，（由于登录密码错误没成功登陆系统的用户）</li>
</ul>
<h3 id="3-12-挂载命令"><a href="#3-12-挂载命令" class="headerlink" title="3.12 挂载命令"></a>3.12 挂载命令</h3><p>Linux 中多有的存储设备必须挂载之后才能使用</p>
<ul>
<li><code>mount [-l]</code>：该命令会显示系统中已挂载的设备<br><img src="https://i.loli.net/2021/03/08/xZrRTBbHotJWV2g.png" alt="image.png"></li>
<li>简单解释：sysfs 挂载到目录 /sys，文件系统是 sysfs，权限是读写</li>
<li><code>fdisk -l</code>：该命令显示系统中的硬件设备</li>
</ul>
<hr>
<p>挂载光盘；<br>光盘挂载前，要指定光盘的设备文件名，不同版本的 Linux 设备文件名不同，但是不论哪个系统都有软链接 /dev/cdrom</p>
<ul>
<li>Centos 5.X 以前的系统，光盘设备文件名是 /dev/hdc</li>
<li>Centos 6.x 以后的系统，光盘设备文件名是 /dev/sr0</li>
<li>挂载光盘命令：<code>mount -t iso9660 设备文件名 空目录 </code>，举例 <code>mount -t iso9660 /dev/cdrom /mnt/cdrom</code>。特别注意：挂载前需要在虚拟机–&gt;设置–&gt;CD/DVD 中选择所使用的 ISO 镜像文件，挂载完一定要记得卸载。<br><img src="https://i.loli.net/2021/03/08/65kvNwbJfOUW7DK.png" alt="image.png"></li>
<li>卸载命令：<code>umount /dev/sr0</code> 或者 <code>umount /mnt/cdrom</code> （卸载的时候需要退出光盘目录才能正常卸载）</li>
</ul>
<hr>
<p>挂载 U 盘：（插入 U 盘的时候，要将鼠标定位在虚拟机的 Linux 系统中）<br>U 盘设备文件名不是固定的，需要手工查询，查询命令 <code>fdisk -l</code></p>
<ul>
<li>挂载命令：<code>mount -t vfat 设备文件名 空目录</code>，例如：<code>mount -t vfat /dev/sdb1 /mnt/usb/</code> vfat 是文件系统的格式。此时查看 U 盘下的内容，中文会以乱码显示，这里可以设定编码格式 <code>mount -t vfat -o iocharset=utf8 /dev/sdb1 /mnt/usb/</code></li>
<li>卸载命令：<code>umount /mnt/usb/</code> （注意：卸载以后才能拔出 U 盘）</li>
</ul>
<hr>
<p><code>mount -a</code>：该命令扫描配置文件 /etc/fstab 的内容，是否有错（但不一定能将错误识别出），没有错会按照该文件的内容自动挂载</p>
<p>mount 命令：</p>
<ul>
<li>格式：<code>mount [-t 文件系统] [-o 特殊选项] 设备文件名 挂载点</code></li>
<li>-o 特殊选项：可以指定挂载的额外选项，比如：读写权限、同步异步等，如果不指定默认值会生效。defaults 相当于 rw,suid,dev,exec,auto,nouser,async 这七个选项。举例：<code>mount -o remount,noexec /boot</code> （重新挂载分区，并将 /boot 目录改为没有执行权限）</li>
</ul>
<hr>
<p>挂载 NTFS 分区：<br>Linux 是不能识别 NTFS 分区的，挂载该分区后也只有只读权限。在实际工作中，很少需要挂载 NTFS 分区，这里重点掌握 Linux 驱动加载的顺序：</p>
<ul>
<li>驱动直接放入系统内核中。这种驱动主要是系统启动加载必须的驱动，数量较少。</li>
<li>驱动以模块的形式放入硬盘。大多数驱动都以这种方式保存，保存位置 /lib/modules/3.10.0-1160.el7.x86_64/kernel 中。</li>
<li>驱动可以被 Linux 识别，但是系统认为这种驱动一般不常用，默认不加载。NTFS 就属于这种情况。</li>
<li>硬件不能被 Linux 识别，需要手工安装驱动。</li>
</ul>
<p>特别注意：移动存储设备不需要设置为开机自动挂载！！！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>从破碎到自由（2020年终总结）</title>
    <url>/posts/2997228924/</url>
    <content><![CDATA[<p>回望过去的 2020 年，整个大环境非同以往，同时也面临着准备毕业和找工作的双重挑战，如果将这一年划分为四季，那大概可以用冬夏春秋来形容吧！</p>
<a id="more"></a>
<h2 id="令人无望的寒冬"><a href="#令人无望的寒冬" class="headerlink" title="令人无望的寒冬"></a>令人无望的寒冬</h2><p>2020 年初的疫情，整个世界按下了暂停键，春季的开学也变得遥遥无期，19 年寒假一直延续到了 20 年的暑假，这期间经历着毫无头脑的毕业论文开题以及纠结不定的春招。<br>【一生的果效是由心发出的（箴言 4 ：23）】。心中所想的往往影响外在的环境，虽然 19 年 8 月才回到研究所里，待了大约 5 个月的时间，说来也怪，短短的 5 个月就能够对一个还未熟悉的老师产生极度的不满，其中的原因听闻周围同学对尊师的论断，从而丧失了自己的判断力。周围人的论断，塑造了老师在我心中的形象，随之带来的是无形中的压力、迷茫以及对自己的否定，回头想想，当初，我在老师心目中的形象就像老师在我心目中的形象。<br>记得寒假放假刚下车准备等公交回家的时候，忽然接到老师让我帮他取快递的电话，我说我回家了，电话那头一顿责备埋怨我为什么不跟他说一声，后来他想起来我跟他请过假了。开题时，毫无头绪，当时没有及时看到开题的通知，老师给我打电话也没听见，微信发消息也没回，等我看到时，内心真的是忐忑不安，怕被骂，不愿意面对，但又不得不面对。总而言之，当时发生的种种事情，都显明了和老师的紧张关系。事已至此，不得不放下对老师的成见，谦卑下来，弃掉悖逆，选择顺服，【在上有权柄的，人人当顺服他（罗马书13 ：1）】。<br>兜兜转转，最终还是要破碎曾经的想法，弃掉曾经的骄傲，若是早醒悟，【行审判不凭眼见，断是非也不凭耳闻（以赛亚书 11 ：3）】。早明白这短短的 15 个字中的奥秘，又何必经历这样的环境呢？</p>
<h2 id="冬天已往酷暑考验"><a href="#冬天已往酷暑考验" class="headerlink" title="冬天已往酷暑考验"></a>冬天已往酷暑考验</h2><p>既然选择了顺服，就要经得住环境的考验。经历诸多的环境，是【要试验我们，看我们凡事顺不顺从（哥林多后书 2 ： 9）】。<br>疫情在家的那段时间，正赶上春招金三银四之时，面遍了各大互联网大厂。在这期间，老师要我帮忙写论文，内心是拒绝的。当时，真的感觉对我又没有什么用，为什么要写？但理性是清楚的，不能拒绝，只能写。于是边准备春招，边拖拖拉拉给老师写论文，同时还要研究自己的毕业论文，遇到老师催论文的时候，难免会应付几句。说来也是神奇，写完一篇，投出去录用了，老师又让写一篇。没有任何可以拒绝的理由，只能写！索性又给老师写了一篇，写完老师的论文，老师又开始催专利。内心依然是拒绝，心想没有专利也能毕业，专利只是实验室的要求，还是不愿意写，想直接写自己的小论文。转眼间到了八月份，开学通知也发了，此时又到了金九银十的秋招之时，经历了春招的毒打，心中已对互联网大厂 say goodbye，确实心里清楚：依然有想去闯一闯的好奇心，但实力原因选择了放弃。</p>
<h2 id="春意到来"><a href="#春意到来" class="headerlink" title="春意到来"></a>春意到来</h2><p>在家的几个月的时间，虽然没有可以量化的成果，但也水了两篇论文，经历了互联网大厂的笔试面试，更了尽两百篇博客，有刷题总结，有面试复盘。内心已不像曾经年少轻狂无知之时，那么刚硬，似乎心中这块土地稍微松软了些，春天已到，眼看就要发芽了。<br>八月份开学后，开始了秋招的征程，同时又邻近毕业论文的中期答辩。心想：没有任何量化的成果，中期可能有点说不过去，大约一个周的时间，索性写了篇专利，改了几稿之后，收到了专利受理通知，至少中期没问题了。重心放在了秋招，此时，心中目标已明确，拒绝一切加班的公司，显然，投递的简历大多是银行、国企，也有几家线上教育公司，偶然的机会听说新浪微博不加班，索性投了下。确实完全没有料到，这个偶然实现了当初去互联网的梦。与此同时，开始了紧锣密鼓地笔试面试，当大家都在焦虑担心之时，说来也奇怪，当时心里有个笃定，一定能拿到 offer，虽然当时的境况和大家一样。印象比较深刻的是，刚开始水了下字节，结果一面挂了，第二次面趋势，面到了三面，本以为能拿到 offer，但至今也没有任何通知，周围同学面贵司的已相继收到感谢信。接着又面好未来，面到了 hr 面，隔周收到了录用通知，当时实验室的同学和室友，基本上都是 0 offer。<br>眼看，即将临近十月一放假，回想开学后的经历，实在是出乎意料，没能想到是实验室第一个拿到 offer 的，没能想到每一次面试的进步，【神位爱他的人所预备的是眼睛未曾看见，耳朵未曾听见，人心也未曾想到的（哥林多前书 2 ： 9）】。</p>
<h2 id="秋收之时"><a href="#秋收之时" class="headerlink" title="秋收之时"></a>秋收之时</h2><p>经历了寒冬的无望，酷暑的考验，春天发芽的喜悦，已到了秋收之时。<br>十一放假结束，再一次回到研究所，已不像八月份开学时对此地的厌烦，似乎这里已成为学习谦卑顺服最合适的环境。回望过去一个半月的时间，发表了一篇专利，经历了隔三差五的面试，拿到了一家公司的录用通知，也有一些还在等消息。毕业要求还要发表一篇小论文，此时，已不再投递简历，边写论文边参加剩余公司的面试。不再像春招时，那样心力交瘁，感觉秋招的整个过程出乎意料的顺利。这期间陆续收到了一些公司的 offer，回想当时的心态，似乎没有十分的激动，好像就像当初的笃定，一定会拿到中意的 offer。之前老师一直要求小论文发在自动化学报上，毕竟是计算机领域三大顶刊之一，还是有一定难度，听周围同学说，有一个很水的会议，EI 检索，跟老师商量了下，老师同意了，投出去一周后收到了录用通知。<br>看似小论文也发完了，offer 也陆续拿到了几个，再完成毕业论文就没什么要紧的事情了。然而，事情并没有想象中那样顺利。<br>同实验室的一同学，他老师为了自己的博士毕业，要求自己的学生发一篇核心期刊，当时这个同学似乎有些焦头烂额，老师要求发核心期刊，工作也没有着落。于是，一心想着水一篇会议，跟老师几次沟通后，老师就是不同意，最后还是硬是发了。他老师誓不罢休，去查了这个会议，发现会议名称有问题，虽然会议名缩写和毕业要求的论文列表里一样，但是全称相差一个单词。研究生部、实验室主任都开始关注这个事情，楼上的博士师兄找组委会开了证明，后来发现证明中语言逻辑有问题，把我们这些投这个会议的同学搞的无言以对，只好找组委会重新开一份证明。此时，那位想博士毕业的老师已经对这个会议质疑到了极点，以至于尊师本不关心这回事，也开始上心起来，要求我再发一篇小论文。给我讲了各种理由，说服我再发一篇论文，我相信【万事都互相效力，叫爱神的人得益处，就是按他旨意被召的人（罗马书 8 ：28）】，也明白这是学习顺服权柄的过程中的一个考验。面对考验，只能得胜，不能失败。于是，向神祷告：主啊，若再写一篇是你的旨意，老师再跟我讲的时候我愿意顺服，也求你赐给我论文的创新点。<br>【你们若听从耶和华——你们神的诫命，就是我今日所吩咐你们的，就必蒙福（申命记 11 ： 27）】。既然选择了顺服，就顺服到底。心想：也没有太要紧的事，再写一篇论文也无所谓。同时和周围同学交流了下，也坚定了再发一篇论文的信心。我发现，当谦卑顺服的时候，会经历到出人意外的顺利，第二篇小论文从投稿，返修，到最终的录用一个月的时间就完事了。周围同学或者网上的说法，最快也要两个月。周围同学问起时，也十分惊讶，怎么这么快？<br>同时，老师又要求针对第二篇小论文发一篇专利，坦白的讲，心中还是有一丝悖逆，觉得和之前那篇专利差不多，重复度太高，没法写。于是，又在专利这僵持了一阵子。把遇到的问题和老师沟通，但有一个准则就是依然要顺服权柄！最终，还是发了第二篇专利！<br>这三个月的经历，如顺水推舟，在不断的磨练中前进。经过这几个月和老师的接触，发现老师对我的态度变了，不再是觉得我什么都不行，方方面面不如前辈好的老旧我。坦白的讲，在当初，立定心志要顺服权柄时，在方方面面去尊敬老师，考虑老师的建议，遇到和老师意见不一致时，不再论断，而是尝试去沟通。就像牛顿讲力的作用是相互的，当我立定心志要转变对老师的态度时，反过来得到的是老师的认可，还有捎而带之的做事情的果效。</p>
<h2 id="回望四季"><a href="#回望四季" class="headerlink" title="回望四季"></a>回望四季</h2><p>回头看这一年的经历，从寒冬的无望，到酷暑的考验，熬过了春雨的洗礼，收获了秋天的果实。【你以恩典为年岁的冠冕，你的路径都滴下脂油（诗篇 65 ： 11）】，经历了破碎，实现了重建，得到了自由。顺便也拿到了 offer，发表了论文，达到了毕业要求，顺而代之的是之前准备春招秋招阶段写的博客也发挥了它的价值赚了些小费，给力扣写了几个月的面经，并把 C++ 部分整理成了面经的电子书，相信不久就能在官网看到。希望在今后的每一年更多的被修理，被更新，被改变。原本打算在 2020 年的年末来完成这篇总结，然而，明天如何真的难料，临近年末，沈阳疫情先后在几个区出现，29 号突然的放假通知，不禁是个大彩蛋，放假的时间真的是刚刚好。第二篇专利刚好完成定稿，第二篇小论文刚好完成返修，三方协议刚好上午找老师盖了章，上午稍微在宿舍收拾了收拾，准备下午继续写大论文，结果快下班的时候，通知放假！第二天，拖着行李，踏上了回家的行程。通知来的如此的突然，但一切似乎又是刚刚好。在家做事难免有些不专心，毕竟马上到而立之年，在家不再像小时候那样的肆无忌惮，到了饭点要想着做饭，家里干活忙要帮着干活，老弟回家要辅导辅导他的功课。拖拖拉拉，眼看快到 1 月中旬才完成了去年的年终总结。</p>
<p>写于 2021 年 1 月 11 日 聊城</p>
]]></content>
      <categories>
        <category>成长轨迹</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux集群学习笔记</title>
    <url>/posts/3367399618/</url>
    <content><![CDATA[<p>集群相关知识，负载均衡、</p>
<a id="more"></a>
<h2 id="1-集群"><a href="#1-集群" class="headerlink" title="1 集群"></a>1 集群</h2><p><strong>定义：</strong> 集群是一组协同工作的服务器，各有分工，对外表现为一个整体。</p>
<h3 id="1-1-集群分类"><a href="#1-1-集群分类" class="headerlink" title="1.1 集群分类"></a>1.1 集群分类</h3><ul>
<li>负载均衡集群-LBC：分担服务的总体压力</li>
<li>高可用集群-HAC：尽可能保障服务状态的可用性</li>
<li>高性能运算集群-HPC：提供单台服务器提供不了的计算能力</li>
</ul>
<h3 id="1-2-负载均衡集群-LBC"><a href="#1-2-负载均衡集群-LBC" class="headerlink" title="1.2 负载均衡集群-LBC"></a>1.2 负载均衡集群-LBC</h3><p>实现方法：</p>
<ul>
<li>软件：LVS、RAC、Nginx</li>
<li>硬件：F5、BIG-IP<br><img src="https://img-blog.csdnimg.cn/20201213225712191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3c5MTg1ODk4NTk=,size_16,color_FFFFFF,t_70" alt="avatar"></li>
</ul>
<p>调度器分类：</p>
<ul>
<li>触发条件：<ul>
<li>四层：传输层 IP+PORT</li>
<li>七层：应用层 URL</li>
</ul>
</li>
<li>实现原理：<ul>
<li>四层：TCP 连接只建立一次，客户端和真正的服务器</li>
<li>七层：TCP 连接建立两次，客户端和负载调度器、负载调度器和真正的服务器</li>
</ul>
</li>
<li>实现场景：<ul>
<li>四层：TCP 应用 例如：基于 C/S 架构的 ERP(Enterprise Resource Planning)管理系统</li>
<li>七层：HTTP 应用 例如：根据用户访问域名的方式，判断用户语言</li>
</ul>
</li>
<li>安全性：<ul>
<li>四层：转发 SYN 攻击</li>
<li>七层：可以拦截 SYN 攻击</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201213230035710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3c5MTg1ODk4NTk=,size_16,color_FFFFFF,t_70"></p>
<h2 id="2-负载均衡集群"><a href="#2-负载均衡集群" class="headerlink" title="2 负载均衡集群"></a>2 负载均衡集群</h2><h3 id="2-1-LVS-相关原理"><a href="#2-1-LVS-相关原理" class="headerlink" title="2.1 LVS 相关原理"></a>2.1 LVS 相关原理</h3><p>LVS（Linux Virtual Server）Linux 虚拟服务器，负载均衡集群的负载调度器，工作在传输层，属于软件层面的负载均衡实现方法。</p>
<p>LVS 组成：</p>
<ul>
<li>IPVS（IP Virtual Server）：运行在内核空间，是运行在 LVS 下提供负载平衡功能的一种技术，主要用于使用户定义的策略生效</li>
<li>IPVSADM：运行在用户空间，管理集群服务的命令工具</li>
</ul>
<p>LVS 原理：根据用户请求的套接字判断，分流至真正服务器的工作模块<br><img src="https://img-blog.csdnimg.cn/20201213231854496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3c5MTg1ODk4NTk=,size_16,color_FFFFFF,t_70"></p>
<p>LVS 只做了简单的地址信息更改，并没有涉及真实的流量转发</p>
<ol>
<li>当用户向负载均衡调度器（Director Server）发起请求，调度器将请求发往至内核空间</li>
<li>PREROUTING 链会首先收到用户请求，确定目标 IP 是本机 IP，将数据包发往 INPUT 链</li>
<li>IPVS 是工作在 INPUT 链上的，当用户请求到达 INPUT 时，IPVS 会将用户请求和自己定义好的集群服务进行比对，如果用户请求的就是定义的集群服务，那么此时 IPVS 会强行修改数据包里的目标 IP 地址及端口，并将新的数据包发往 POSTROUTING 链</li>
<li>POSTROUTING 链接收到数据包后发现目标 IP 地址刚好是自己的后端服务器，那么此时通过选路，将数据包最终发送给后端的服务器</li>
</ol>
<h3 id="2-2-LVS-工作方式"><a href="#2-2-LVS-工作方式" class="headerlink" title="2.2 LVS 工作方式"></a>2.2 LVS 工作方式</h3><p><img src="https://img-blog.csdnimg.cn/20201214222230953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3c5MTg1ODk4NTk=,size_16,color_FFFFFF,t_70"></p>
<p>RS(Real server)：真实服务器<br>DS(Director server)：负载均衡服务器<br>DIP(Director server IP)：负载均衡服务器 IP<br>RIP(Real server IP)：真实服务器 IP<br>VIP(Virtual server IP)：虚拟服务器 IP<br>CIP(Client IP)：客户端 IP</p>
<h4 id="2-2-1-NAT-模式"><a href="#2-2-1-NAT-模式" class="headerlink" title="2.2.1 NAT 模式"></a>2.2.1 NAT 模式</h4><p>负载调度器拥有两块网卡，一块公网 IP，一块内网 IP<br><img src="https://i.loli.net/2021/02/25/WCQbNg9DcIYv72w.png" alt="image.png"><br>特点：</p>
<ul>
<li>集群节点处于同一个网络中</li>
<li>真实服务器必须将网关指向负载调度器</li>
<li>RIP 通常是私有 IP，仅用于各集群节点通信</li>
<li>负载调度器必须位于 RS 和 客户端 之间，充当网关</li>
<li>支持端口映射，公网和内网的IP 地址、端口号的转换</li>
<li>负载调度器必须是 Linux 系统，真实服务器随意</li>
<li>进出数据保温都要经过负载调度器，压力较大</li>
</ul>
<p>原理：<br>通过网络地址转换来实现服务器的调度。</p>
<ol>
<li>调度器（LB）收到客户端请求的数据包，根据调度算法决定将请求的数据包发送给哪个后端的真实服务器。</li>
<li>然后调度器就把客户端发送的请求数据包的目标 IP 地址和端口号改成真实服务器的 IP 地址和端口号，这样真实服务器就能够接收到客户端请求的数据包了。</li>
<li>真实服务器响应完请求后，查看默认路由（NAT 模式下需要将 RS 默认路由设置成 LB 服务器，也就是调度器），把响应后的数据包发送给 LB。</li>
<li>LB 接收到响应包，把源地址改成虚拟地址（VIP）然后发动给客户端。</li>
</ol>
<h4 id="2-2-2-DR-模式"><a href="#2-2-2-DR-模式" class="headerlink" title="2.2.2 DR 模式"></a>2.2.2 DR 模式</h4><p>DR (Direct Routing) 直接路由器模式<br><img src="https://i.loli.net/2021/02/26/4otkgJInYAdL2ED.png" alt="image.png"><br>工作原理：<br>DR 模式将报文直接路由给目标真实服务器。</p>
<ol>
<li>调度器根据真实服务器的负载情况，动态的选择一台路由器，不修改目标 IP 和目标端口，也不封装 IP 报文，而是将请求报文的数据帧的目标 MAC 地址改为真实服务器的 MAC 地址。</li>
<li>然后将修改的数据帧在服务器组的局域网上发送。因为数据帧的 MAC 地址是真实服务器的 MAC 地址，并且又在同一个局域网，那么根据局域网的通信原理，真实服务器一定能够收到由 LB 发出的数据包。</li>
<li>真实服务器收到数据包后，查看到目标 IP 是 VIP。（此时只有自己的 IP 符合目标 IP 才会接受进来，所以需要在本地回环接口上配置 VIP。由于网络接口都会进行 ARP 广播响应，但集群的其他机器都有这个 VIP 的 lo 接口，都响应就会冲突，所以要把真实服务器的 lo 接口的 ARP 响应关掉。）</li>
<li>然后真实服务器做成请求响应，之后根据自己的路由信息将这个响应数据包发送给客户端，并且源 IP 依然是 VIP。</li>
</ol>
<p>特点：</p>
<ul>
<li>集群节点处于同一个广播域中</li>
<li>真实服务器将网关指向真实路由器</li>
<li>负载调度器只负责处理入站请求，压力最小</li>
<li>不支持端口映射</li>
<li>负载调度器必须是 Linux，真实服务器最好是 Linux</li>
</ul>
<h4 id="2-2-3-TUN-模式"><a href="#2-2-3-TUN-模式" class="headerlink" title="2.2.3 TUN 模式"></a>2.2.3 TUN 模式</h4><p><img src="https://i.loli.net/2021/02/27/WM5zAKwoiNXhqSs.png" alt="image.png"></p>
<p>采用 NAT 模式，由于请求和响应的报文必须通过调度器将地址重写，当客户端的请求越来越多时，调度器的处理能力将成为瓶颈。为了解决这个问题，调度器将请求报文通过 IP 隧道转发到真实的服务器，真实的服务器将响应处理后的数据直接返回给客户端。这样调度器就只处理请求入站报文。</p>
<p>工作原理：</p>
<ol>
<li>客户请求数据包，目标地址 VIP 发送到 LB 上；</li>
<li>LB 接收到客户请求包，进行 IP Tunnel 封装，即在原有的包头加上 IP Tunnel 的包头。然后发送出去；</li>
<li>RS 节点服务器根据 IP Tunnel 包头信息（此时就是一种逻辑上的隐形隧道，只有 LB 和 RS 之间懂）收到请求包，然后解开 IP Tunnel 包头信息，得到客户的请求包，并进行响应处理；</li>
<li>响应处理完后，RS 服务器使用自己的公网线路，将这个响应数据包发送给客户端，源地址依然是 VIP 地址</li>
</ol>
<p>特点：</p>
<ul>
<li>集群所有节点都必须直接/间接拥有公网地址</li>
<li>真实服务器必须将网关指向真实网关</li>
<li>不支持端口映射</li>
<li>DS 与 RS 必须开启隧道功能</li>
<li>入站由 DS 完成，出站由 RS 完成</li>
<li>负载调度器必须是 Linux 操作系统，真实服务器随意</li>
<li>压力较大，需要大量的数据包的封装和解封</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 编辑器</title>
    <url>/posts/2687411960/</url>
    <content><![CDATA[<p>主要讲解 vim 编辑器的相关命令</p>
<a id="more"></a>
<!-- TOC -->

<ul>
<li><a href="#1-vi-%E7%BC%96%E8%BE%91%E5%99%A8%E7%AE%80%E4%BB%8B">1 vi 编辑器简介</a></li>
<li><a href="#2-vim-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">2 vim 基本使用</a><ul>
<li><a href="#21-vim-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">2.1 vim 工作模式</a></li>
<li><a href="#22-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E6%93%8D%E4%BD%9C">2.2 命令模式操作</a></li>
</ul>
</li>
<li><a href="#3-vim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7">3 vim 使用技巧</a><ul>
<li><a href="#31-%E5%9C%A8-vim-%E4%B8%AD%E5%AF%BC%E5%85%A5%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%88%96%E5%91%BD%E4%BB%A4%E7%BB%93%E6%9E%9C">3.1 在 vim 中导入其他文件内容或命令结果</a></li>
<li><a href="#32-%E8%AE%BE%E5%AE%9A%E5%BF%AB%E6%8D%B7%E9%94%AE">3.2 设定快捷键</a></li>
<li><a href="#33-%E5%AD%97%E7%AC%A6%E6%9B%BF%E6%8D%A2">3.3 字符替换</a></li>
<li><a href="#34-%E5%A4%9A%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80">3.4 多文件打开</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-vi-编辑器简介"><a href="#1-vi-编辑器简介" class="headerlink" title="1 vi 编辑器简介"></a>1 vi 编辑器简介</h2><p>vim 编辑器是 vi 编辑器的增强版，会有颜色显示，可以执行 vi 命令时候，执行的就是 vim。将命令 <code>alias vi=&#39;vim&#39;</code> 写入文件 ~/.bashrc </p>
<h2 id="2-vim-基本使用"><a href="#2-vim-基本使用" class="headerlink" title="2 vim 基本使用"></a>2 vim 基本使用</h2><h3 id="2-1-vim-工作模式"><a href="#2-1-vim-工作模式" class="headerlink" title="2.1 vim 工作模式"></a>2.1 vim 工作模式</h3><p><img src="https://i.loli.net/2021/03/09/BmOTFuVvdfnQiay.png" alt="image.png"><br>输入模式：主要用于文本编辑，和记事本类似，输入数据就好。</p>
<ul>
<li>进入输入模式的方法：（记住其中一个就好）</li>
<li>a：在光标所在字符后插入</li>
<li>A：在光标所在行尾插入</li>
<li>i：在光标所在字符前插入</li>
<li>I：在光标所在行行首插入</li>
<li>o：在光标下插入新行</li>
<li>O：在光标上插入新行</li>
</ul>
<p>末行模式：（编辑模式）</p>
<ul>
<li>:w 保存不退出</li>
<li>:w 新文件名  把文件另存为新文件</li>
<li>:q 不保存退出</li>
<li>:wq 保存退出</li>
<li>! 强制</li>
<li>:q! 强制不保存退出，用于修改文件之后，不保存数据退出</li>
<li>:wq! 强制保存退出，当文件的所有者或者 root 用户，对文件没有写权限的时候，强制写入数据 </li>
</ul>
<h3 id="2-2-命令模式操作"><a href="#2-2-命令模式操作" class="headerlink" title="2.2 命令模式操作"></a>2.2 命令模式操作</h3><p>光标的移动：</p>
<ul>
<li>上下左右的移动：上下左右的箭头 或者 HJKL（左下上右）</li>
<li>移动到该行的开始：^</li>
<li>移动到该行的结束：$</li>
<li>移动到文档的开始：gg</li>
<li>移动到文档的结束：G （shift+g）</li>
<li>移动到指定行：:n （n是数字，移动到第几行就填几）</li>
</ul>
<hr>
<p>删除/剪切一个或多个字符：</p>
<ul>
<li>x 删除1个</li>
<li>nx 删除n个（从光标位置开始向后删除连续的n个）</li>
</ul>
<p>删除/剪切一行或多行：</p>
<ul>
<li>dd 删除一行</li>
<li>ndd 删除多行</li>
<li>n1,n2d 从第n1行删除到第n2行</li>
<li>dG 从当前光标位置一直删除到文档的最后（G），如果光标在当前文档的开始那么删除的是整篇文档</li>
</ul>
<p>粘贴：</p>
<ul>
<li>p 在当前光标的下一行粘贴</li>
<li>P（大写）在当前光标的上一行粘贴</li>
</ul>
<p>撤销：</p>
<ul>
<li>u 撤销操作</li>
<li>ctrl+r 反撤销操作</li>
</ul>
<p>复制一行或多行：</p>
<ul>
<li>yy 复制一行</li>
<li>nyy 复制多行</li>
</ul>
<hr>
<p>vim 配置文件，如果需要下述配置永久生效，就需要将下述命令写入 ~/.vimrc 文件中。（注意：写入的时候不用加冒号）更多设置参数，可执行命令 :set all 查看</p>
<ul>
<li>显示与取消行号：:set nu / :set nonu，nu 表示 number</li>
<li>是否显示隐藏字符：:set list / :set nolist</li>
<li>是否依据语法显示颜色帮助：:syntax on / :syntax off</li>
<li>是否将查找的字符串高亮显示：:set hlsearch / :set nohlsearch</li>
<li>是否显示右下角的状态栏：:set ruler / :set noruler</li>
<li>是否显示左下角的状态栏：:set showmode / :set noshowmode</li>
</ul>
<p>特别注意：Windows 下的空格（^M$）和 Linux 下的空格（$）不同，特别是在写Shell脚本时，从 Windows下拷贝来的文件需要使用命令 dos2unix 将 Windows 格式转化为 Linux 格式，反过来，命令 unix2dos 就是把 Linux 格式转化为 Windows 格式。（这两个命令需要手动安装后才能使用）</p>
<hr>
<p>查找：</p>
<ul>
<li>从光标所在行向下查找：/查找内容</li>
<li>从光标所在行向上查找：?查找内容</li>
<li>下一个：n</li>
<li>上一个：N</li>
</ul>
<p>替换：</p>
<ul>
<li>:n1,n2s/old/new/g ： 将n1行到n2行中的所有 old 替换为 new，g表示所有内容</li>
<li>:%s/old/new/g ：将整个文本中的 old 替换为 new</li>
<li>举例：</li>
<li>例1：将前10行加上注释 # ，命令 <code>:1,10s/^/#/g</code>。（也就是将行首符^替换为#）取消注释 <code>:1,10s/^#//g</code> （将行首的#替换为空，这里一定要标识行首的#）</li>
<li>例2：将前10行加上注释 //，注意/要加上转义符（\），命令 <code>:1,10s/^/\/\//g</code> 。取消注释 <code>:1,10s/^\/\///g</code></li>
</ul>
<h2 id="3-vim-使用技巧"><a href="#3-vim-使用技巧" class="headerlink" title="3 vim 使用技巧"></a>3 vim 使用技巧</h2><h3 id="3-1-在-vim-中导入其他文件内容或命令结果"><a href="#3-1-在-vim-中导入其他文件内容或命令结果" class="headerlink" title="3.1 在 vim 中导入其他文件内容或命令结果"></a>3.1 在 vim 中导入其他文件内容或命令结果</h3><ul>
<li>导入其他文件内容：<code>:r 文件路径</code> ，将其他文件导入光标所在位置</li>
<li>在 vim 中执行系统命令 <code>:!命令</code></li>
<li>在 vim 中执行系统命令，并导入命令结果至光标所在位置 <code>:r !命令</code></li>
</ul>
<h3 id="3-2-设定快捷键"><a href="#3-2-设定快捷键" class="headerlink" title="3.2 设定快捷键"></a>3.2 设定快捷键</h3><p>设定快捷键时，要想永久生效依然要写入配置文件 ~/.vimrc</p>
<ul>
<li>格式：<code>:map 快捷键 快捷键的执行命令</code> </li>
<li>常定义的快捷键：<ul>
<li><code>:map ^p I#&lt;ESC&gt;</code> 按 ctrl+p 时，在行首加入注释。特别注意：^p 不能手动输入，需要执行 ctrl+v+p 或者 ctrl+v，然后 ctrl+p 来定义，可看到颜色变化。</li>
<li><code>:map ^b ^x</code> 按 ctrl+b 时，删除行首的第一个字母（删除注释）</li>
</ul>
</li>
</ul>
<h3 id="3-3-字符替换"><a href="#3-3-字符替换" class="headerlink" title="3.3 字符替换"></a>3.3 字符替换</h3><ul>
<li>格式：<code>:ab 源字符 替换为字符</code></li>
<li>举例：<code>:ab mymail 1436058432@qq.com</code></li>
<li>注意：源字符不易设置太短，否则影响输入。使用时，键入源字符后，空格或者回车即可变成需要替换的字符。</li>
</ul>
<h3 id="3-4-多文件打开"><a href="#3-4-多文件打开" class="headerlink" title="3.4 多文件打开"></a>3.4 多文件打开</h3><p>同时打开两个文件：</p>
<ul>
<li><code>vim -o 文件名1 文件名2</code> 上下打开两个文件，按下 ctrl+w 后，可通过上下箭头在两个文件中切换</li>
<li><code>vim -O 文件名1 文件名2</code> 左右打开两个文件，按下 ctrl+w 后，可通过左右箭头在两个文件中切换 </li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 软件包安装</title>
    <url>/posts/3333022318/</url>
    <content><![CDATA[<p>主要讲解 Linux 软件包安装的方法。</p>
<a id="more"></a>
<!-- TOC -->

<ul>
<li><a href="#1-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E5%88%86%E7%B1%BB">1 软件包的分类</a><ul>
<li><a href="#11-%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%88%86%E7%B1%BB">1.1 软件包分类</a></li>
<li><a href="#12-%E6%BA%90%E7%A0%81%E5%8C%85">1.2 源码包</a></li>
<li><a href="#13-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85">1.3 二进制包</a></li>
</ul>
</li>
<li><a href="#2-rmp-%E5%8C%85%E5%AE%89%E8%A3%85">2 rmp 包安装</a><ul>
<li><a href="#21-rpm-%E5%8C%85%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">2.1 rpm 包命名规则</a></li>
<li><a href="#22-%E4%BE%9D%E8%B5%96%E6%80%A7">2.2 依赖性</a></li>
<li><a href="#23-rpm-%E6%89%8B%E5%B7%A5%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85">2.3 rpm 手工命令安装</a></li>
<li><a href="#24-rpm%E5%8C%85%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85-yum-%E5%AE%89%E8%A3%85">2.4 rpm包在线安装 （yum 安装）</a></li>
</ul>
</li>
<li><a href="#3-%E6%BA%90%E7%A0%81%E5%8C%85%E5%AE%89%E8%A3%85">3 源码包安装</a><ul>
<li><a href="#31-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">3.1 注意事项</a></li>
<li><a href="#32-%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95">3.2 安装方法</a></li>
</ul>
</li>
<li><a href="#4-%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F">4 脚本安装程序</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-软件包的分类"><a href="#1-软件包的分类" class="headerlink" title="1 软件包的分类"></a>1 软件包的分类</h2><h3 id="1-1-软件包分类"><a href="#1-1-软件包分类" class="headerlink" title="1.1 软件包分类"></a>1.1 软件包分类</h3><ul>
<li>源码包 （rpm 包，光盘中直接包含）</li>
<li>二进制包（需要用户去官网下载）</li>
</ul>
<h3 id="1-2-源码包"><a href="#1-2-源码包" class="headerlink" title="1.2 源码包"></a>1.2 源码包</h3><p>优点：</p>
<ul>
<li>可自由选择所需的功能</li>
<li>软件是编译安装，更加适合自己的系统，更加稳定效率也更高</li>
<li>卸载方便</li>
</ul>
<p>缺点：</p>
<ul>
<li>安装步骤较多，尤其安装较大的额软件集合时（例如：LAMP环境搭建），容易出现拼写错误</li>
<li>编译过程时间较长，安装比二进制安装时间长</li>
<li>编译安装，安装过程一旦出错新手很难解决</li>
</ul>
<h3 id="1-3-二进制包"><a href="#1-3-二进制包" class="headerlink" title="1.3 二进制包"></a>1.3 二进制包</h3><p>分类：</p>
<ul>
<li>DPKG 包：是由 Debian Linux 开发出来的包管理机制，主要应用在 Debian 和 unbuntu 中。</li>
<li>RPM 包：是有 Red Hat 公司开发的包管理系统，目前很多 Linux 都使用这种包管理方式，包括 Fedora、CentOS、SuSE等</li>
</ul>
<p>优点：</p>
<ul>
<li>包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载</li>
<li>安装速度比源码包安装快的多</li>
</ul>
<p>缺点：</p>
<ul>
<li>经过编译，无法看到源码</li>
<li>功能选择不如源码包灵活</li>
<li>依赖性</li>
</ul>
<p>软件包的选择建议：</p>
<ul>
<li>源码包：如果服务是给大量客户端提供访问（例如：LAMP），建议使用源码包，源码包效率更高</li>
<li>RPM 包：如果程序是给少量用户访问，或者本地使用，建议 RPM 包，因为 RPM 管理方便</li>
</ul>
<p>RPM 包依赖：</p>
<ul>
<li>树形依赖 a–&gt;b–&gt;c</li>
<li>环形依赖 a–&gt;b–&gt;c–&gt;a ，可以同时安装这几个包</li>
<li>模块（函数库）依赖，当出现函数库（后缀名.s0.数字）依赖时，需要在网站 <a href="http://www.rpmfind.net/">www.rpmfind.net</a> 中查询该函数库属于哪一个软件包</li>
</ul>
<p>RPM 包的安装方法：</p>
<ul>
<li>手动安装</li>
<li>yum 命令安装</li>
</ul>
<h2 id="2-rmp-包安装"><a href="#2-rmp-包安装" class="headerlink" title="2 rmp 包安装"></a>2 rmp 包安装</h2><h3 id="2-1-rpm-包命名规则"><a href="#2-1-rpm-包命名规则" class="headerlink" title="2.1 rpm 包命名规则"></a>2.1 rpm 包命名规则</h3><p>举例：sip-4.14.6-4.el7.x86_64.rpm</p>
<ul>
<li>sip：软件包名</li>
<li>4.14.6：软件版本</li>
<li>4：软件发布的次数</li>
<li>el7：软件发行商</li>
<li>x86_64：适合的硬件平台</li>
<li>rpm：rpm 包的扩展名</li>
</ul>
<p>包全名：如果操作的是未安装的软件包，则使用包全名，而且需要注意绝对路径<br>包名：如果操作的是已安装的软件包，则使用包名即可，系统会生产 RPM 包的数据库（/var/lib/rpm/），而且可以在任意路径下操作</p>
<h3 id="2-2-依赖性"><a href="#2-2-依赖性" class="headerlink" title="2.2 依赖性"></a>2.2 依赖性</h3><p>参考上文</p>
<h3 id="2-3-rpm-手工命令安装"><a href="#2-3-rpm-手工命令安装" class="headerlink" title="2.3 rpm 手工命令安装"></a>2.3 rpm 手工命令安装</h3><ol>
<li>安装命令：</li>
</ol>
<ul>
<li>命令：<code>rpm -ivh 包全名</code> 注意：这里的包全名一定要写绝对路径，如果不写绝对路径，要求必须在该路径下进行安装</li>
<li>选项：-i 表示 install 安装；-v 显示更详细的信息（verbose）；-h 打印#显示安装进度</li>
<li>特别注意：一些函数依赖需要在网站 <a href="http://www.rpmfind.net/">www.rpmfind.net</a> 中查询该函数库属于哪一个软件包</li>
<li>举例：<code>rpm -ivh httpd-</code> 按 Tab 键，安装 Apache 相关的包</li>
<li>安装位置：使用选项 <code>--prefix=安装路径</code> 指定安装位置。但是 rpm 包建议安装在默认的路径，因为默认安装位置是系统的习惯位置，并且 RPM 包管理系统是有卸载命令的，数据库会记录安装位置。源码包最好指定安装位置。</li>
<li>选项：<code>--force</code> 强制安装，不管是否已安装，都会重新安装；<code>--test</code> 测试安装，不会实际安装，只是检测下依赖性。</li>
</ul>
<ol start="2">
<li>启动服务：</li>
</ol>
<ul>
<li>命令：<code>service 服务名 start|stop|restart|status</code> 或者 <code>服务所在的路径 start|restart|stop</code> (例如：<code>/etc/rc.d/init.d/httpd restart</code> 或者 <code>/etc/init.d/httpd restart</code> /etc/init.d/httpd 是前一个目录的软链接)</li>
<li>参数：start 启动服务；stop 停止服务；restart 重启服务；status 查看服务状态</li>
<li>说明：如果安装的是 Apache 相关的包，启动服务后可以通过 IP 地址访问 Apache 的测试网页(网页的位置：/var/www/html，如果该网页所在的目录是空的，可以新建一个默认网页 index.html，该文件必须以 index 命名，且以 html 作为后缀名)，但注意要临时关闭防火墙（Centos7 临时关闭防火墙的命令 <code>systemctl stop firewalld</code>）。</li>
</ul>
<p>配置文件位置<br>/etc/httpd/conf/httpd.conf</p>
<ol start="3">
<li>RPM 包升级</li>
</ol>
<ul>
<li>命令：<code>rpm -Uvh 包全名</code>，<code>-U</code>（大写） 选项表示如果系统没有安装，则直接安装，如果安装版本较旧则升级到最新版本</li>
<li>命令：<code>rpm -Fvh 包全名</code>，<code>-F</code> 选项表示如果没有安装，则不会安装，必须安装了旧版本才会升级。</li>
</ul>
<ol start="4">
<li>RPM 包卸载</li>
</ol>
<ul>
<li>命令：<code>rpm -e 包名</code></li>
<li>选项：<code>--nodeps</code> 不检查依赖性，但不建议使用</li>
</ul>
<ol start="5">
<li>查询（rpm 包的安装、升级和卸载都可以被 yum 命令取代，但是查询不能被 yum 取代，yum 查询的是服务器，而不是本地）</li>
</ol>
<ul>
<li>查询软件包是否安装：<code>rpm -q 包名</code>，例如：<code>rpm -q httpd</code>，q 表示 query</li>
<li>查询系统中所有的安装包：<code>rpm -qa</code>，借助该命令查询软件包是否安装 <code>rpm -qa | grep 包名</code></li>
<li>查询软件包的详细信息：i 表示 information<ul>
<li>查询已安装的包：<code>rpm -qi 包名</code></li>
<li>查询未安装的包：<code>rpm -qip 包全名</code></li>
</ul>
</li>
<li>查询软件包中的文件列表和安装的完整目录：l 表示 list<ul>
<li>查询已安装的包：<code>rpm -ql 包名</code></li>
<li>查询未安装的包：<code>rpm -qlp 包全名</code>，这里列出的是该软件包预安装的路径</li>
</ul>
</li>
<li>查询系统文件属于哪个软件包：f 表示 file <code>rpm -qf 文件路径</code></li>
<li>查询软件包所依赖的软件包：R 表示 Requires <ul>
<li>已安装的软件包：<code>rpm -qR 包名</code></li>
<li>未安装的软件包：<code>rpm -qRp 包全名</code></li>
</ul>
</li>
</ul>
<ol start="6">
<li>验证</li>
</ol>
<ul>
<li>验证已安装的软件包：<code>rpm -V 包名</code></li>
<li>验证所有软件包：<code>rpm -Va</code></li>
<li>验证某个系统文件是否被修改：<code>rpm -Vf 系统文件名</code>，如果修改了会给出一些详细信息<br><img src="https://i.loli.net/2021/03/10/3cz4fMPqRF2a75j.png" alt="image.png"></li>
</ul>
<ol start="7">
<li>数字证书<br>只能对已安装的 rpm 包起作用，其目的是保证从官网下的文件没被修改过。只有安装了数字证书，才会对 rpm 包进行验证。</li>
</ol>
<ul>
<li>安装 rpm 包的命令：<code>rpm --import 数字证书存储路径</code>，数字证书在光盘文件中就有 /mnt/cdrom/RPM-GPG-KEY-CenOS-7，也会默认放在系统中 /etc/pki/rpm-grg/RPM-GPG-KEY-CentOS-7</li>
<li>查看系统中安装好的数字证书：<code>rpm -qa | grep gpg-pubkey</code></li>
</ul>
<h3 id="2-4-rpm包在线安装-（yum-安装）"><a href="#2-4-rpm包在线安装-（yum-安装）" class="headerlink" title="2.4 rpm包在线安装 （yum 安装）"></a>2.4 rpm包在线安装 （yum 安装）</h3><ol>
<li>yum 源文件解析<br>yum 配置文件的位置 /etc/yum.repos.d/ 文件的扩展名是 *.repo<br><img src="https://i.loli.net/2021/03/12/PTmx6euDSaZk8LA.png" alt="image.png"></li>
</ol>
<ul>
<li>[base] 容器名称，一定要放在 [] 中</li>
<li>name 容器说明，可以随便写</li>
<li>mirrorlist 镜像站点，可以注释掉</li>
<li>baseurl yum 源服务器的地址</li>
<li>enable 表示该服务器是否生效 =1 表示生效，=0 表示不生效</li>
<li>gpgcheck 为 1 表示数字证书生效，为 0 表示数字证书不生效</li>
<li>gpgkey 数字证书公钥文件保存位置</li>
</ul>
<ol start="2">
<li>搭建本地光盘 yum 源<br>说明：默认情况下，网络 yum 源（CentOS-Base）生效，这里是配置下使得光盘 yum 源（Centos-Media）生效</li>
</ol>
<ul>
<li>挂载光盘：<code>mount /dev/cdrom /mnt/cdrom/</code></li>
<li>将其余几个 yum 源配置文件失效，改下扩展名即可，例如：<code>mv CentOS-Base.repo Centos-Base.repo.bak</code></li>
<li>修改 yum 源配置文件 Centos-Media.repo<ul>
<li>将 baseurl 改为光盘的挂载地址 /mnt/cdrom，其余两行注释掉</li>
<li>enable 改为 =1</li>
</ul>
</li>
</ul>
<ol start="3">
<li>yum 命令</li>
</ol>
<ul>
<li>查询 yum 源服务器上可安装的软件包：<code>yum list</code></li>
<li>查询 yum 源服务器中是否包含某个软件包：<code>yum list 包名</code></li>
<li>查询 yum 源服务器上所有和关键字相关的软件包: <code>yum search 关键字</code></li>
<li>查询 yum 源服务器上某个软件所在的包：<code>yum search 软件名</code></li>
<li>查询指定软件包的信息：<code>yum info 软件包名</code></li>
<li>安装软件包：<code>yum -y install 包名</code> 选项 <code>-y</code> 表示安装过程中自动回答 yes，否则需要手工回答 yes。注意：这里只需要包名，而不需要包全名，在 yum 中不会用到包全名</li>
<li>升级软件包：<code>yum -y update 包名</code> ，注意：这里如果不注明包名会升级所有的软件包（不建议这样操作）</li>
<li>卸载软件包：<code>yum remove 包名</code> ，注意：卸载命令可能会导致系统崩溃，因为涉及到不同包之间的依赖</li>
</ul>
<ol start="4">
<li>yum 组管理命令</li>
</ol>
<ul>
<li>查询可安装的软件组：<code>yum grouplist</code></li>
<li>查询某个软件组的详细信息：<code>yum groupinfo 组名</code></li>
<li>安装某个软件组：<code>yum groupinstall 组名</code></li>
<li>卸载某个软件组：<code>yum groupremove 组名</code></li>
</ul>
<h2 id="3-源码包安装"><a href="#3-源码包安装" class="headerlink" title="3 源码包安装"></a>3 源码包安装</h2><h3 id="3-1-注意事项"><a href="#3-1-注意事项" class="headerlink" title="3.1 注意事项"></a>3.1 注意事项</h3><p>源码包需要在官网下载后，才能安装，光盘中没有。</p>
<p>使用源码包安装 Apache，和使用二进制包（RPM 包）安装 Apache，安装位置不同。<br>RPM 包安装：（不建议指定安装位置，建议安装在默认位置，RPM 包安装的服务有标准的卸载命令，不怕文件到处安装）</p>
<ul>
<li>配置文件：/etc/httpd/conf/httpd.conf</li>
<li>网页位置：/var/www/html/</li>
<li>日志位置：/var/log/httpd/</li>
<li>启动方法：service httpd restart  或者  /etc/rc.d/init.d/httpd restart</li>
</ul>
<p>源码包安装：（源码包没有安装数据库，没有删除命令，如需删除直接删除安装目录即可）</p>
<ul>
<li>配置文件：/usr/local/apache2/conf/httpd.conf</li>
<li>网页文件：/usr/local/apache2/htdocs/</li>
<li>日志位置：/usr/local/apache2/logs/</li>
<li>启动方法：/usr/local/apache2/bin/apachectl start</li>
</ul>
<h3 id="3-2-安装方法"><a href="#3-2-安装方法" class="headerlink" title="3.2 安装方法"></a>3.2 安装方法</h3><ol>
<li>下载安装包</li>
<li>解压缩：如果安装包是 *.tar.gz 形式，<code>tar -zxvf 安装包的下载位置</code></li>
<li>进入解压目录</li>
<li>编译前准备 <code>./configure --prefix=安装路径</code> （这里是执行 configure 命令）安装路径 /usr/local/apache2/ （这里 2 表示版本号）</li>
<li>编译 <code>make</code></li>
<li>清空编译内容（非必需步骤，只有在编译前准备或者编译过程中报错才需要清空）<code>make clean</code></li>
<li>编译安装 <code>make install</code> （此时才会向指定的安装路径下写入内容）</li>
</ol>
<h2 id="4-脚本安装程序"><a href="#4-脚本安装程序" class="headerlink" title="4 脚本安装程序"></a>4 脚本安装程序</h2><p>XShell 中的上传（上传到 Linux）和下载工具（下载到 Windows）：lrsz</p>
<ul>
<li>安装命令： <code>rpm -ivh lrsz(Tab键)</code></li>
<li>上传命令：<code>rz</code> （会弹出来一个框，来选择上传什么文件）</li>
<li>下载命令：<code>sz Linux系统中的文件名</code> </li>
</ul>
<p>使用脚本安装软件的步骤：</p>
<ol>
<li>下载好压缩文件</li>
<li>将压缩文件解压</li>
<li>进入解压后的目录</li>
<li>执行脚本文件 例如：<code>./setip.sh</code></li>
</ol>
<p>说明：使用脚本安装软件是将软件安装过程中的安装命令写在了 Shell 脚本中</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 用户管理、权限管理</title>
    <url>/posts/3199649610/</url>
    <content><![CDATA[<p>主要讲解 Linux 用户管理、文件权限方面的知识</p>
<a id="more"></a>
<!-- TOC -->

<ul>
<li><a href="#1-%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6">1 用户相关文件</a><ul>
<li><a href="#11-etcpasswd-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%96%87%E4%BB%B6">1.1 /etc/passwd 用户信息文件</a></li>
<li><a href="#12-etcshadow-%E5%BD%B1%E5%AD%90%E6%96%87%E4%BB%B6">1.2 /etc/shadow 影子文件</a></li>
<li><a href="#13-etcgroup-%E7%BB%84%E4%BF%A1%E6%81%AF%E6%96%87%E4%BB%B6">1.3 /etc/group 组信息文件</a></li>
</ul>
</li>
<li><a href="#2-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4">2 用户管理命令</a><ul>
<li><a href="#21-%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7">2.1 添加用户</a></li>
<li><a href="#22-%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81">2.2 设置密码</a></li>
<li><a href="#23-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E4%BF%AE%E6%94%B9">2.3 用户信息修改</a></li>
<li><a href="#24-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7">2.4 删除用户</a></li>
<li><a href="#25-%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD">2.5 切换用户身份</a></li>
</ul>
</li>
<li><a href="#3-%E7%BB%84%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4">3 组管理命令</a><ul>
<li><a href="#31-%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E7%BB%84">3.1 添加用户组</a></li>
<li><a href="#32-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E7%BB%84">3.2 删除用户组</a></li>
<li><a href="#33-%E6%8A%8A%E7%94%A8%E6%88%B7%E6%B7%BB%E5%8A%A0%E8%BF%9B%E7%BB%84%E6%88%96%E4%BB%8E%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4">3.3 把用户添加进组或从组中删除</a></li>
</ul>
</li>
<li><a href="#4-acl-%E6%9D%83%E9%99%90">4 ACL 权限</a></li>
<li><a href="#5-sudo-%E6%8E%88%E6%9D%83">5 sudo 授权</a></li>
<li><a href="#5-%E6%96%87%E4%BB%B6%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90-setuidsetgidsticky-bit">5 文件特殊权限 SetUID、SetGID、Sticky BIT</a><ul>
<li><a href="#51-setuid">5.1 SetUID</a></li>
<li><a href="#52-setgid">5.2 SetGID</a></li>
<li><a href="#53-sticky-bit">5.3 Sticky BIT</a></li>
<li><a href="#54-%E8%AE%BE%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90">5.4 设定文件的特殊权限</a></li>
</ul>
</li>
<li><a href="#6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7-chattr-%E6%9D%83%E9%99%90">6 文件系统属性 chattr 权限</a></li>
<li><a href="#%E6%9D%83%E9%99%90%E6%80%BB%E7%BB%93">权限总结</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-用户相关文件"><a href="#1-用户相关文件" class="headerlink" title="1 用户相关文件"></a>1 用户相关文件</h2><h3 id="1-1-etc-passwd-用户信息文件"><a href="#1-1-etc-passwd-用户信息文件" class="headerlink" title="1.1 /etc/passwd 用户信息文件"></a>1.1 /etc/passwd 用户信息文件</h3><p>root:x:0:0:root:/root:/bin/bash</p>
<ul>
<li>第一列：root 用户名</li>
<li>第二列：x 密码位 （x 表示当前用户有密码，而不是说当前用户的密码是x）</li>
<li>第三列：用户 UID<ul>
<li>0 超级用户 UID （将普通用户升级成管理员用户只需该第三列即可）</li>
<li>1-499 系统用户（伪用户，用户不能登录，只是用来启动服务的）</li>
<li>500-60000 普通用户 UID</li>
</ul>
</li>
<li>第四列：组 ID （GID 添加用户时，如果不指定所属组，那么会建立和用户名相同的组）</li>
<li>第五列：用户说明</li>
<li>第六列：用户家目录</li>
<li>第七列：登录 Shell</li>
</ul>
<h3 id="1-2-etc-shadow-影子文件"><a href="#1-2-etc-shadow-影子文件" class="headerlink" title="1.2 /etc/shadow 影子文件"></a>1.2 /etc/shadow 影子文件</h3><p><img src="https://i.loli.net/2021/03/12/glHmjIpALUeviyu.png" alt="image.png"></p>
<ul>
<li>第一列：root 用户名</li>
<li>第二列：加密密码，可以在密码前人为加入 <code>!</code>或者 <code>*</code> 改变加密值让密码暂时失效，使该用户无法登录，达到暂时禁止用户登录的效果。（注意：所有的伪用户都是 <code>!!</code> 或 <code>*</code> ）</li>
<li>第三列：密码最近更改时间，1970 年 1 月 1 日作为标准时间<ul>
<li>时间戳转日期：<code>date -d &quot;1970-01-01 15775 days&quot;</code></li>
<li>日期转时间戳：<code>echo $(($(date --date=&quot;2013/03/11&quot; +%s)/86400+1))</code></li>
</ul>
</li>
<li>第四列：两次密码修改的间隔时间（和第3字段相比）</li>
<li>第五列：密码有效期（和第3字段相比）</li>
<li>第六列：密码修改到期前的警告天数（和第5字段相比）</li>
<li>第七列：密码过期后的宽限天数（和第5字段相比）</li>
<li>第八列：密码失效时间（超过了失效时间，即使密码没有过期，用户也会失效无法使用）</li>
<li>第九列：保留</li>
</ul>
<h3 id="1-3-etc-group-组信息文件"><a href="#1-3-etc-group-组信息文件" class="headerlink" title="1.3 /etc/group 组信息文件"></a>1.3 /etc/group 组信息文件</h3><p>root:x:0:root</p>
<ul>
<li>第一列：root 组名</li>
<li>第二列：x 组密码</li>
<li>第三列：GID</li>
<li>第四列：此组中支持的其他用户。附加组是此组的用户<ul>
<li>初始组：每个用户初始组只能有一个，初始组只能有一个，一般都是和用户名相同的组作为初始组</li>
<li>附加组：每个用户可以属于多个附加组，如果把用户加入组，都是加入附加组</li>
</ul>
</li>
</ul>
<p>组密码文件：/etc/gshadow<br>用户的家目录：/home/用户名<br>用户邮箱目录：/var/spool/mail，例如：user1用户的邮箱目录 /var/spool/mail/user1<br>用户模板目录：/etc/skel （创建用户时，会将模板目录中的文件拷贝到用户的家目录下）</p>
<p>添加用户命令：<code>useradd 用户名</code><br>给用户创建密码：<code>passwd 用户名</code></p>
<h2 id="2-用户管理命令"><a href="#2-用户管理命令" class="headerlink" title="2 用户管理命令"></a>2 用户管理命令</h2><h3 id="2-1-添加用户"><a href="#2-1-添加用户" class="headerlink" title="2.1 添加用户"></a>2.1 添加用户</h3><ul>
<li>命令：<code>useradd 用户名</code></li>
<li>useradd 添加用户时参考的默认文件：/etc/default/useradd 和 /etc/login.defs</li>
</ul>
<p><img src="https://i.loli.net/2021/03/13/kv7hLTm2ARWGS4K.png" alt="image.png"><br>/etc/default/useradd 文件中的内容：</p>
<ul>
<li>GROUP：建立用户的默认组，添加每个用户时，用户的初始组就是 GID 为 100 的这个用户组，但是目前采用的是私有用户组机制（创建一个用户时，为该用户创建一个同名的组作为用户的初始组）</li>
<li>HOME：用户的家目录的默认位置</li>
<li>INACTIVE：密码过期后宽限的天数，/etc/shadow 文件的第7个字段。该值为0，表示代码过期后立即失效；该值为-1，表示代码永远不会失效。</li>
<li>EXPIRE：密码失效时间，/etc/shadow 文件的第八个字段。默认值为空，所有新建的用户没有失效时间。</li>
<li>SHELL：用户的默认 shell。/bin/bash 是 Linux 的标志 shell，所以所有新建立的用户默认都具备 shell 权限</li>
<li>SKEL：定义用户的模板目录位置</li>
<li>CREATE_MAIL_SPOOL：定义是否给用户建立邮箱，默认是创建</li>
</ul>
<p>/etc/login.defs</p>
<ul>
<li>MAIL_DIR：邮箱的默认路径</li>
<li>PASS_MAX_DAYS：指定密码的有效期，/etc/shadow 的第5字段，即多少天后必须修改密码</li>
<li>PASS_MIN_DAYS：两次密码修改的间隔时间，/etc/shadow 的第4字段</li>
<li>PASS_MIN_LEN：密码的最短长度，现在已被 PAM 模块取代，这个选项并不生效</li>
<li>PASS_WARN_AGE：密码修改到期前的警告天数，/etc/shadow 的第6字段</li>
<li>UID_MIN、UID_MAX：创建用户时，最小 UID 和最大 UID 的范围</li>
<li>GID_MIN、GID_MAX：GID 的最小值和最大值</li>
<li>CREATE_HOME：创建用户时，是否自动建立家目录</li>
<li>UMASK：建立的用户家目录的默认权限</li>
<li>USERGROUPS_ENAB：使用命令 userdel 删除用户时，是否删除用户的初始组，默认是删除的</li>
<li>ENCRYPT_METHOD：用户密码的加密方式</li>
</ul>
<h3 id="2-2-设置密码"><a href="#2-2-设置密码" class="headerlink" title="2.2 设置密码"></a>2.2 设置密码</h3><ul>
<li>命令：<code>passwd [选项] 用户名</code></li>
<li>选项：<code>-l</code> 暂时锁定用户（仅 root 用户可用）；<code>-u</code> 解锁用户（仅 root 用户可用）；<code>--stdin</code> 可以将通过管道符输出的数据作为用户的密码，主要在批量添加用户时使用</li>
<li><code>passwd</code> 表示修改当前用户的密码</li>
<li>Shell 中常用修改用户密码命令：<code>echo &quot;新密码&quot; | passwd --stdin 用户名</code></li>
<li>设置用户一登录就要修改密码（将密码修改日期归 0，即 shadow 第 3 字段）：<code>chage -d 0 用户名</code></li>
</ul>
<h3 id="2-3-用户信息修改"><a href="#2-3-用户信息修改" class="headerlink" title="2.3 用户信息修改"></a>2.3 用户信息修改</h3><ul>
<li>命令：<code>usermod [选项] 用户名</code></li>
<li>选项：<code>-g 组名</code> 修改用户的初始组（/etc/passwd 第 4 字段），<code>-G 组名</code> 修改用户的附加组</li>
</ul>
<h3 id="2-4-删除用户"><a href="#2-4-删除用户" class="headerlink" title="2.4 删除用户"></a>2.4 删除用户</h3><ul>
<li>命令：<code>userdel [-r] 用户名</code></li>
<li>选项：<code>-r</code> 选项表示在删除用户的同时删除用户的家目录（如果不加上该选项需要手动删除用户的家目录）</li>
</ul>
<h3 id="2-5-切换用户身份"><a href="#2-5-切换用户身份" class="headerlink" title="2.5 切换用户身份"></a>2.5 切换用户身份</h3><ul>
<li>命令：<code>su [选项] 用户名</code></li>
<li>选项：<code>-</code> 代表连带用户的环境变量一起切换（但是版本6以后的系统就没有此限制，不加该选项也会切换环境变量）</li>
<li>显示环境变量的命令：<code>env</code></li>
<li>退出当前用户命令：<code>exit</code></li>
</ul>
<h2 id="3-组管理命令"><a href="#3-组管理命令" class="headerlink" title="3 组管理命令"></a>3 组管理命令</h2><h3 id="3-1-添加用户组"><a href="#3-1-添加用户组" class="headerlink" title="3.1 添加用户组"></a>3.1 添加用户组</h3><ul>
<li>命令：<code>groupadd [选项] 组名</code></li>
<li>选项：<code>-g GID</code> 指定组 ID</li>
</ul>
<h3 id="3-2-删除用户组"><a href="#3-2-删除用户组" class="headerlink" title="3.2 删除用户组"></a>3.2 删除用户组</h3><ul>
<li>命令：<code>groupdel 组名</code></li>
<li>注意：要删除的组不能是其他用户的初始组，即只有组中没有初始用户时才能删除</li>
</ul>
<h3 id="3-3-把用户添加进组或从组中删除"><a href="#3-3-把用户添加进组或从组中删除" class="headerlink" title="3.3 把用户添加进组或从组中删除"></a>3.3 把用户添加进组或从组中删除</h3><ul>
<li>命令：<code>gpasswd [选项] 组名</code></li>
<li>选项：<code>-a 用户名</code> 把用户加入组；<code>-d 用户名</code> 把用户从组中删除</li>
<li>注意区分 usermod 命令：使用 usermod 命令将用户加入组 <code>usermod -G 组名 用户名</code> （与 gpasswd 中用户名和组名的顺序不同）</li>
</ul>
<h2 id="4-ACL-权限"><a href="#4-ACL-权限" class="headerlink" title="4 ACL 权限"></a>4 ACL 权限</h2><p>ACL 权限是用来解决用户对文件身份不足的问题的。<br><img src="https://i.loli.net/2021/03/14/HaBFb2wS4eLVsR8.png" alt="image.png"></p>
<p>查询 ACL 权限是否开启的命令：<code>dumpe2fs -h /dev/sda3</code></p>
<ul>
<li>dumpe2fs：查询指定分区详细文件系统信息的命令</li>
<li>-h：仅显示超级块中的信息，而不显示磁盘块组的详细信息<br><img src="https://i.loli.net/2021/03/14/qNypOZQvhKVjuYC.png" alt="image.png"></li>
</ul>
<hr>
<p>为用户设定 ACL 权限：</p>
<ul>
<li>命令：<code>setfacl -m u:用户名:权限值 目录名或文件名</code>，例如：<code>setfacl -m u:st:5 /www/</code></li>
</ul>
<hr>
<p>查询文件的 ACL 权限：</p>
<ul>
<li>命令：<code>getfacl 文件名或目录名</code></li>
</ul>
<hr>
<p>给目录下的文件赋予 ACL 权限：<code>-R</code></p>
<ul>
<li><p>命令 1：<code>setfacl -m u:用户名:权限值 -R 目录名</code>，例如：<code>setfacl -m u:st:5 -R /www/</code></p>
</li>
<li><p>功能：将该目录下已存在的文件赋予 ACL 权限，上述为用户设定 ACL 权限的命令，只是让这个目录具有 ACL 权限，而该目录下的文件不具有 ACL 权限。</p>
</li>
<li><p>命令 2：<code>setfacl -m d:u:用户名:权限值 -R 目录名</code></p>
</li>
<li><p>功能：将该目录下以后建立的文件赋予 ACL 权限</p>
</li>
<li><p>注意：ACL 权限一旦递归之后，容易出现权限溢出</p>
</li>
</ul>
<hr>
<p>最大有效权限：(mask)</p>
<ul>
<li>命令：<code>setfacl -m m:权限值 目录名</code></li>
<li>功能：用户的最大有效权限是用户本身的权限和 mask 相与的结果</li>
</ul>
<hr>
<p>删除 ACL 权限：</p>
<ul>
<li>删除指定用户的 ACL 权限：<code>setfacl -x u:用户名 目录名</code></li>
<li>删除文件的所有 ACL 权限：<code>setfacl -b 目录名</code></li>
</ul>
<h2 id="5-sudo-授权"><a href="#5-sudo-授权" class="headerlink" title="5 sudo 授权"></a>5 sudo 授权</h2><p>给普通用户赋予部分管理员的权限。目录 /sbin/ 和目录 /usr/sbin/ 下的命令只有超级用户才能使用。</p>
<p>赋予的权限越详细，普通用户得到的权限越小；（针对授权命令而言）<br>赋予的权限越简单，普通用户得到的权限越大。（针对授权命令而言）</p>
<p>执行命令 <code>visudo</code> 可以打开授权文件，按照如下格式写入文件 <code>用户名或组名 被管理主机的地址=（可用的身份 授权命令）</code>，例如：<code>user1 ALL=/sbin/shutdown -r now</code></p>
<ul>
<li>用户名或者组名：如果是组名需要在名字前加上 <code>%</code></li>
<li>被管理的主机地址：常用 <code>ALL</code></li>
<li>可用的身份：就是将源用户切换成什么身份使用，（ALL）代表可以切换成任意身份，该字段可以省略</li>
<li>授权命令：代表把什么命令授权给普通用户，默认是 ALL，表示任何命令。授权命令一定要写成绝对路径的形式。</li>
<li>说明：给用户授权相应的命令后，可以以该用户登录系统，使用 <code>sudo -l</code> 查询可用的授权。执行所授权的命令的时候要写成如下格式：<code>sudo 绝对路径形式的授权命令</code>，例如：<code>sudo /sbin/shutdown -r now</code></li>
</ul>
<h2 id="5-文件特殊权限-SetUID、SetGID、Sticky-BIT"><a href="#5-文件特殊权限-SetUID、SetGID、Sticky-BIT" class="headerlink" title="5 文件特殊权限 SetUID、SetGID、Sticky BIT"></a>5 文件特殊权限 SetUID、SetGID、Sticky BIT</h2><p>SUID：只能针对执行程序<br>SGID：既可以针对执行文件，也可以针对目录文件<br>SBIT：只能针对目录</p>
<h3 id="5-1-SetUID"><a href="#5-1-SetUID" class="headerlink" title="5.1 SetUID"></a>5.1 SetUID</h3><ul>
<li>命令：<code>chmod 4xxx 文件名</code>，xxx 表示三位数字权限，例如：<code>chmod 4755 /test</code></li>
<li>命令：<code>chmod u+s 文件名</code>，u 表示所有者 </li>
</ul>
<p>功能：</p>
<ul>
<li>只有可以执行的二进制程序才能设定 SUID 权限（该文件具有执行权限，即文件的所有者、所属组、其他人都具有 x 权限）</li>
<li>命令执行者要对该程序拥有 x （执行）权限（命令的执行者所对应的角色对该文件具有执行权限，角色指的是所有者、所属组、其他人）</li>
<li>命令执行者在执行该程序时获得该程序的属主身份，也就是在执行该文件的过程中，命令的执行者变为该文件的所有者</li>
<li>SetUID 权限只能在该程序执行过程中有效，即身份的改变只在该程序的执行过程中生效</li>
</ul>
<p>举例：普通用户只能修改自己的密码</p>
<ul>
<li>用户想要修改密码，一方面需要使用 <code>passwd</code> 命令，另一方面需要能修改 /etc/shadow 文件</li>
<li><code>passwd</code> 命令：在 /usr/bin/passwd 文件中，查看该文件的属性 <code>-rwsr-xr-x. 1 root root 27856 4月   1 2020 /usr/bin/passwd</code> （当一个具有执行权限的文件设置 SetUID 权限后，用户执行这个文件时将以文件所有者的身份执行）</li>
<li>passwd 文件的所有者为 root，root 用户能够修改 /etc/shadow 文件，从而使得普通用户能修改自己的密码<br><img src="https://i.loli.net/2021/03/15/PMGaYRONe8jZvHd.png" alt="image.png"></li>
</ul>
<p>特别注意：一般不会去修改文件的 SGID 权限，而且关键目录例如：/、/usr 等应严格控制写权限。</p>
<h3 id="5-2-SetGID"><a href="#5-2-SetGID" class="headerlink" title="5.2 SetGID"></a>5.2 SetGID</h3><ul>
<li>命令：<code>chmod 2xxx 文件名或目录名</code>，xxx 表示三位数字权限，例如：<code>chmod 2755 /test</code></li>
<li>命令：<code>chmod g+s 文件名</code>，g 表示所属组 </li>
</ul>
<ol>
<li>针对文件的作用</li>
</ol>
<ul>
<li>只有可执行的二进制程序才能设置 SGID 权限</li>
<li>命令的执行者要对该程序拥有 x （执行）权限</li>
<li>命令执行在执行程序的时候，组身份升级为该程序文件的属组</li>
<li>SGID 权限同样只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效</li>
</ul>
<p>举例：locate 命令</p>
<ul>
<li>该命令在执行的时候，其实是在数据库中进行查找，即查找 /var/lib/mlocate/mlocate.db 文件，该文件对于其他用户而言没有任何权限，对于所属组具有 r 权限</li>
<li>但是 locate 命令，即 /usr/bin/locate 文件对于文件的所属组具有 SGID 权限，也就是说当其他用户执行 locate 命令时，其他用户的所属组会变为 /usr/bin/locate 文件的所属组，从而对数据库文件 /var/lib/mlocate/mlocate.db 具有读权限，使得普通用户能使用 locate 命令</li>
</ul>
<ol start="2">
<li>针对目录的作用（不太重要）<br>功能：</li>
</ol>
<ul>
<li><p>普通用户必须对此目录拥有 r 和 x 权限，才能进入此目录</p>
</li>
<li><p>普通用户在此目录的有效组会变成此目录的属组</p>
</li>
<li><p>若普通用户对此目录拥有 w 权限时，新建的文件的默认数组是这个目录的属组。（如果将该目录设置了 SGID 权限。必须要给该目录赋予 w 权限，即改为 777）</p>
</li>
<li><p>实践表明：如果 A 用户对一个目录设置 SGID 权限，当另外一个用户 B 在该目录下建立文件时，该文件的所属组依然是 A。</p>
</li>
</ul>
<h3 id="5-3-Sticky-BIT"><a href="#5-3-Sticky-BIT" class="headerlink" title="5.3 Sticky BIT"></a>5.3 Sticky BIT</h3><p>Sticky BIT 称为粘着位，简称为 SBIT，SBIT 目前仅针对目录有效。</p>
<ul>
<li>命令：<code>chmod 1xxx 目录名</code>，xxx 表示三位数字权限，例如：<code>chmod 1755 /test</code></li>
<li>命令：<code>chmod o+t 文件名</code>，o 表示其他用户</li>
</ul>
<p>作用：</p>
<ul>
<li>普通用户对该目录拥有 w 和 x 权限，即普通用户可以在此目录拥有写入权限</li>
<li>如果没有粘着位，因为普通用户拥有 w 权限，所以可以删除此目录下所有文件包括其他用户建立的文件。一旦赋予了粘着位，除了 root 用户可以删除所有文件，普通用户就算拥有 w 权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件。例如：/tmp 目录</li>
</ul>
<h3 id="5-4-设定文件的特殊权限"><a href="#5-4-设定文件的特殊权限" class="headerlink" title="5.4 设定文件的特殊权限"></a>5.4 设定文件的特殊权限</h3><ul>
<li>4 表示 SUID</li>
<li>2 表示 SGID</li>
<li>1 表示 SBIT</li>
</ul>
<h2 id="6-文件系统属性-chattr-权限"><a href="#6-文件系统属性-chattr-权限" class="headerlink" title="6 文件系统属性 chattr 权限"></a>6 文件系统属性 chattr 权限</h2><p>（以上设置的权限仅对普通用户生效，但是 chattr 命令设置的权限对 root 用户也生效）</p>
<p>设置权限：</p>
<ul>
<li>命令：<code>chattr [+-=选项] 文件或目录名</code></li>
<li><code>+</code> 表示增加权限，<code>-</code> 表示删除权限，<code>=</code> 等于某权限</li>
<li>选项：<ul>
<li><code>i</code>（insert）对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；对目录设置 i 属性，那么只能修改目录下文件的数据，但不允许建立和删除文件。</li>
<li><code>a</code>（append）：如果对文件设置 a 属性，只能在文件中增加数据，但是不能删除也不能修改数据，所以不能用 vim 对文件进行编辑，可以使用 echo 向文件中写入数据；如果对目录设置 a 属性，那么只能在目录中建立和修改文件，但是不允许删除。</li>
<li><code>e</code>：Linux 中绝大多数的文件都默认拥有 e 属性。表示该文件是使用 ext 文件系统进行存储，而且不能使用 <code>chattr -e 文件名或目录名</code> 命令取消 e 属性。</li>
</ul>
</li>
</ul>
<p>查看文件系统属性：</p>
<ul>
<li>命令：<code>lsattr 选项 文件名</code></li>
<li>选项：-a 显示所有文件和目录；-d 若目标是目录，仅列出目录本身的属性，而不是子文件</li>
</ul>
<h2 id="权限总结"><a href="#权限总结" class="headerlink" title="权限总结"></a>权限总结</h2><p>所有者（u）、所属组（g）其他用户（o） rwx 权限<br>umask 默认权限<br>ACL 权限 （解决用户对文件身份不足的问题）<br>sudo 授权（给普通用户授予管理员的权限）<br>SUID、GUID、SBIT</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件系统管理</title>
    <url>/posts/1492347987/</url>
    <content><![CDATA[<p>主要讲解 Linux 文件系统管理方面的知识</p>
<a id="more"></a>

<h2 id="1-硬盘结构"><a href="#1-硬盘结构" class="headerlink" title="1 硬盘结构"></a>1 硬盘结构</h2><p>硬盘接口：</p>
<ul>
<li>IDE 硬盘接口：早期的机械硬盘的主要接口</li>
<li>SATA 接口：目前常用的是这种</li>
<li>SCSI 接口：广泛应用在服务器上，不过现在服务器也一般用 SATA 接口</li>
</ul>
<h2 id="2-常用硬盘管理命令"><a href="#2-常用硬盘管理命令" class="headerlink" title="2 常用硬盘管理命令"></a>2 常用硬盘管理命令</h2><h3 id="2-1-df-命令"><a href="#2-1-df-命令" class="headerlink" title="2.1 df 命令"></a>2.1 df 命令</h3><ul>
<li><code>df [-ahT]</code> ：展示文件系统的信息</li>
<li>-a：显示特殊文件系统，这些文件系统几乎都是保存在内存中的，所以占用量都是 0</li>
<li>-h：单位换成习惯单位，而不是 KB</li>
<li>-T：多出了文件系统类型</li>
</ul>
<h3 id="2-2-du-命令"><a href="#2-2-du-命令" class="headerlink" title="2.2 du 命令"></a>2.2 du 命令</h3><ul>
<li><code>du [选项] [目录或文件名]</code> 统计文件的大小。注意：使用 <code>ls -l 文件名或目录名</code> 命令显示的文件大小是准确的，但是目录的大小不准确。</li>
<li>选项：-a 显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量；-h 使用习惯单位显示磁盘占用量；-s 统计总占用量</li>
</ul>
<p>区别：</p>
<ul>
<li>du 用于统计文件大小的，统计文件大小是准确的</li>
<li>df 用于统计空间大小，统计剩余空间是准确的</li>
</ul>
<h3 id="2-3-fsck-文件系统修复命令（知道就行）"><a href="#2-3-fsck-文件系统修复命令（知道就行）" class="headerlink" title="2.3 fsck 文件系统修复命令（知道就行）"></a>2.3 fsck 文件系统修复命令（知道就行）</h3><ul>
<li>命令：<code>fsck -y 文件系统</code> 文件系统可用 <code>df</code> 命令来查看。例如：<code>fsck -y /dev/sdb1</code></li>
</ul>
<h3 id="2-4-显示磁盘状态-dumpe2fs"><a href="#2-4-显示磁盘状态-dumpe2fs" class="headerlink" title="2.4 显示磁盘状态 dumpe2fs"></a>2.4 显示磁盘状态 dumpe2fs</h3><ul>
<li>命令：<code>dumpe2fs 文件系统</code>。例如：<code>dumpe2fs /dev/sda3</code></li>
</ul>
<h3 id="2-5-查看文件的详细时间"><a href="#2-5-查看文件的详细时间" class="headerlink" title="2.5 查看文件的详细时间"></a>2.5 查看文件的详细时间</h3><ul>
<li>命令：<code>stat 文件名</code></li>
</ul>
<h3 id="2-6-判断文件类型"><a href="#2-6-判断文件类型" class="headerlink" title="2.6 判断文件类型"></a>2.6 判断文件类型</h3><ul>
<li><code>file 文件名或目录名</code> 判断文件类型</li>
<li><code>type 命令名</code> 判断命令类型</li>
</ul>
<h2 id="3-fdisk-命令手工分区"><a href="#3-fdisk-命令手工分区" class="headerlink" title="3 fdisk 命令手工分区"></a>3 fdisk 命令手工分区</h2><ul>
<li>查看系统所有硬盘及分区的命令：<code>fdisk -l</code></li>
</ul>
<p>步骤：</p>
<ol>
<li><p>添加一块硬盘。</p>
</li>
<li><p>对硬盘进行分区，执行命令 <code>fdisk /dev/sdb</code> 进入命令交互</p>
</li>
<li><p>参考如下命令建立分区：（注意建立完分区后，保存退出）<br><img src="https://i.loli.net/2021/03/16/GMdZJbNTY5EPasA.png" alt="image.png"></p>
</li>
<li><p>格式化，执行命令：<code>mkfs -t ext4 /dev/sdb1</code>，<code>-t 文件系统</code> 表示指定格式化成哪个文件系统</p>
</li>
<li><p>建立挂载点，（即建立一个空目录）<code>mkdir 目录名</code></p>
</li>
<li><p>挂载 <code>mount /dev/sdb1 /disk1</code></p>
</li>
<li><p>查看分区，以下命令都可以：</p>
<ul>
<li>mount 查看所有已挂载的分区和光盘</li>
<li>fdisk -l 查看系统分区</li>
<li>df 查看分区占用百分比</li>
</ul>
</li>
<li><p>自动挂载，修改文件 /etc/fstab，让系统启动时自动挂载</p>
</li>
<li><p>重启测试，执行命令 <code>mount -a</code> 或者 <code>reboot</code></p>
</li>
</ol>
<h2 id="4-etc-fstab-文件修复"><a href="#4-etc-fstab-文件修复" class="headerlink" title="4 /etc/fstab/ 文件修复"></a>4 /etc/fstab/ 文件修复</h2><p>/etc/fstab 是为了让新加入的硬盘开机自动挂载而需要在该文件中添加相关的内容。<br>但是上述文件一旦写错，就会导致系统启动失败，想要修复该文件，必须在服务器本机处理，远程无法处理。</p>
<p>解决方法：修改 /etc/fstab 文件，但此时没有权限修改该文件，需要将该分区重新挂载，挂载为读写权限，执行命令 <code>mount -o remount,rw /</code> （该命令是重新挂载分区，并将根目录改为有读写权限），这样就可以重新启动了。</p>
<h2 id="5-parted-命令分区"><a href="#5-parted-命令分区" class="headerlink" title="5 parted 命令分区"></a>5 parted 命令分区</h2><p>Linux 系统中只有两种分区表 MBR 分区表和 GPT 分区表，使用 GPT 分区表时，需要使用命令 parted 来调整分区。</p>
<p>步骤：</p>
<ol>
<li>进入交互模式，<code>parted 分区名</code></li>
<li>执行相应的命令可进行分区，参考如下列表<br><img src="https://i.loli.net/2021/03/16/rnOcTANUIDPaCGS.png" alt="image.png"><br><img src="https://i.loli.net/2021/03/16/1tVnazRGIqANsif.png" alt="image.png"></li>
<li>查看分区：交互模式下 <code>print</code></li>
<li>修改成 GPT 分区 <code>mklabel gpt</code>，该过程需要重新启动系统，但要记得将 /etc/fstab 文件中之前加入的开机自动挂载的一行内容删除掉</li>
<li>建立分区 交互模式下 <code>mkpart</code></li>
<li>建立文件系统 交互模式下 <code>mkfs</code></li>
</ol>
<p>注：听到了 99 节课，高级文件系统管理部分没有听完</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell 编程</title>
    <url>/posts/3909341753/</url>
    <content><![CDATA[<p>主要讲解 Shell 编程</p>
<a id="more"></a>

<h2 id="1-Shell-概述"><a href="#1-Shell-概述" class="headerlink" title="1 Shell 概述"></a>1 Shell 概述</h2><p>Shell：将外层应用程序翻译成内核能够识别的二进制<br><img src="https://i.loli.net/2021/03/16/S9bs8lOKvGLfNqr.png" alt="image.png"></p>
<p>Shell 分为很多种，常用的是 Bash，可通过执行 <code>vi /etc/shells</code> 来查看 Linux 支持的 Shell</p>
<h2 id="2-Shell-脚本执行方式"><a href="#2-Shell-脚本执行方式" class="headerlink" title="2 Shell 脚本执行方式"></a>2 Shell 脚本执行方式</h2><h3 id="2-1-echo-命令"><a href="#2-1-echo-命令" class="headerlink" title="2.1 echo 命令"></a>2.1 echo 命令</h3><ul>
<li><p>格式：<code>echo [选项] [输出内容]</code></p>
</li>
<li><p>选项：-e 支持反斜线控制的字符转换；-n 取消输出后行末的换行符（输出后不换行）</p>
</li>
<li><p>-e 选项可以支持的控制字符如下：<br><img src="https://i.loli.net/2021/03/16/y6Zvl1TXCi47hdJ.png" alt="image.png"></p>
</li>
<li><p>更改输出内容的字体颜色：<code>echo -e &quot;\e[1;31m safa \e[0m&quot;</code> 31m 表示红色 safa是输出的内容</p>
</li>
</ul>
<h3 id="2-2-Shell-脚本执行"><a href="#2-2-Shell-脚本执行" class="headerlink" title="2.2 Shell 脚本执行"></a>2.2 Shell 脚本执行</h3><p>在写 Shell 脚本时，需要加上 <code>#!/bin/bash</code>，以便说明下述程序是 Shell 脚本。</p>
<ul>
<li>执行方法一：<code>bash 脚本文件名</code>，例如：<code>bash hello.sh</code></li>
<li>执行方法二：</li>
<li>首先给脚本文件赋予执行权限：<code>chmod 755 脚本文件名</code>，例如 <code>chmod 755 hello.sh</code></li>
<li>然后输入文件路径就可执行：例如 <code>./hello.sh</code></li>
</ul>
<h2 id="3-Bash-基本功能"><a href="#3-Bash-基本功能" class="headerlink" title="3 Bash 基本功能"></a>3 Bash 基本功能</h2><h3 id="3-1-历史命令"><a href="#3-1-历史命令" class="headerlink" title="3.1 历史命令"></a>3.1 历史命令</h3><ul>
<li>命令：<code>history [选项] [历史命令保存文件]</code></li>
<li>选项：-c 清空历史命令；-w 将缓存中的历史命令写入保存文件，如果不手工指定，默认放入 ~/.bash_history</li>
<li>历史命令保存文件可通过设置文件 /etc/profile 中 HISTSIZE 的大小来改变</li>
</ul>
<p>历史命令的调用：</p>
<ul>
<li>上下箭头调用以前的历史命令</li>
<li><code>!n</code> 重复执行第 n 条历史命令</li>
<li><code>!!</code> 重复执行上一条命令</li>
<li><code>!字符串</code> 重复执行最后一条以该字符串开头的命令</li>
<li><code>!$</code> 重复执行上一条命令的最后一个参数</li>
</ul>
<h3 id="3-2-命令与文件补全"><a href="#3-2-命令与文件补全" class="headerlink" title="3.2 命令与文件补全"></a>3.2 命令与文件补全</h3><p>TAB 键</p>
<h3 id="3-3-命令别名"><a href="#3-3-命令别名" class="headerlink" title="3.3 命令别名"></a>3.3 命令别名</h3><ul>
<li><code>alias</code>：查询命令别名</li>
<li><code>alias 别名=&#39;原名令&#39;</code> 设定命令别名，如果要让别名永久生效需要写入配置文件 ~/.bashrc</li>
</ul>
<p>命令的优先级：（由高到低）</p>
<ul>
<li>执行用绝对路径或相对路径的命令</li>
<li>执行别名</li>
<li>执行 Bash 的内部命令</li>
<li>执行按照 $PATH 环境变量定义的目录查找顺序找到第一个命令</li>
</ul>
<h3 id="3-4-Bash-常用快捷键"><a href="#3-4-Bash-常用快捷键" class="headerlink" title="3.4 Bash 常用快捷键"></a>3.4 Bash 常用快捷键</h3><ul>
<li><code>ctrl + A</code>：把光标移动到命令行开头</li>
<li><code>ctrl + E</code>：把光标移动到命令行结尾</li>
<li><code>ctrl + C</code>：强制终止当前命令</li>
<li><code>ctrl + L</code>：清屏，相当于 <code>clear</code> 命令</li>
<li><code>ctrl + U</code>：删除或剪切光标之前的命令</li>
<li><code>ctrl + K</code>：删除或剪切光标之后的内容</li>
<li><code>ctrl + Y</code>：粘贴剪切的内容</li>
<li><code>ctrl + R</code>：从历史命令中搜索</li>
<li><code>ctrl + D</code>：退出当前终端</li>
<li><code>ctrl + Z</code>：暂停并放入后台</li>
<li><code>ctrl + S</code>：暂停屏幕输出</li>
<li><code>ctrl + Q</code>：恢复屏幕输出</li>
</ul>
<h3 id="3-5-输入输出重定向"><a href="#3-5-输入输出重定向" class="headerlink" title="3.5 输入输出重定向"></a>3.5 输入输出重定向</h3><ol>
<li>Bash 标准输入重定向 </li>
</ol>
<ul>
<li>键盘（标准输入）：/dev/stdin 文件描述符（0）</li>
<li>显示器（标准输出）：/dev/stdout 文件描述符（1）</li>
<li>显示器（标准错误输出）：/dev/stderr 文件描述符（2）</li>
</ul>
<ol start="2">
<li>输出重定向</li>
</ol>
<ul>
<li><code>命令 &gt; 文件</code>：以覆盖方式将命令输出到指定文件</li>
<li><code>命令 &gt;&gt; 文件</code>：以追加方式将命令输出到指定文件</li>
<li><code>命令 &gt; 文件 2&gt;&amp;1</code> 或 <code>命令 &amp;&gt; 文件</code>：以覆盖方式将正确输出和错误输出保存到同一个文件中 （2 表示标准错误输出）</li>
<li><code>命令 &gt;&gt; 文件 2&gt;&amp;1</code> 或 <code>命令 &amp;&gt;&gt; 文件</code>：以追加方式将正确输出和错误输出保存到同一个文件中</li>
<li><code>命令 &gt;&gt; 文件1 2&gt;&gt;文件2</code>：将正确的输出追加到文件1中，将错误的输出追加到文件2中</li>
</ul>
<ol start="3">
<li>输入重定向（了解）</li>
</ol>
<p>输入重定向：<code>&lt;</code> 例如：<code>wc &lt; /abc</code> （其实这个小于号不加也没有影响）</p>
<ul>
<li>命令：<code>wc [选项] [文件名]</code></li>
<li>选项：-c 统计字节数；-w 统计单词数；-l 统计行数</li>
</ul>
<h3 id="3-6-多命令顺序执行"><a href="#3-6-多命令顺序执行" class="headerlink" title="3.6 多命令顺序执行"></a>3.6 多命令顺序执行</h3><p>多命令顺序执行符：</p>
<ul>
<li><code>;</code>：<code>命令1;命令2</code> 多个命令顺序执行，命令之间没有任何逻辑关系</li>
<li><code>&amp;&amp;</code>：<code>命令1 &amp;&amp; 命令2</code> 只有当命令1正确执行时，才会执行命令2；否则只会执行命令1</li>
<li><code>||</code>：<code>命令1 || 命令2</code> 只有当命令1执行不正确时，才会执行命令2；否则只会执行命令1</li>
</ul>
<h3 id="3-7-管道符"><a href="#3-7-管道符" class="headerlink" title="3.7 管道符"></a>3.7 管道符</h3><ol>
<li>行提取命令 grep</li>
</ol>
<ul>
<li>格式：<code>grep [选项] “搜索内容” 文件名</code></li>
<li>选项：<ul>
<li>-A 数字：列出符合条件的行，并列出后续的 n 行</li>
<li>-B 数字：列出符合条件的行，并列出前面的 n 行</li>
<li>-c：统计找到符合条件的字符串的次数</li>
<li>-i：忽略大小写</li>
<li>-n：输出行号</li>
<li>-v：反向查找</li>
<li>–color=auto：搜索出关键字用颜色显示</li>
</ul>
</li>
</ul>
<ol start="2">
<li>管道符</li>
</ol>
<ul>
<li>格式：<code>命令1 | 命令2</code></li>
<li>功能：针对命令1的执行结果执行命令2</li>
<li>用例：</li>
<li>将查询的内容分屏显示：<code>ll -a /etc/ | more</code></li>
<li>查询下本地所有的连接，提取包含 ESTABLISH 的行：<code>netstat -an | grep &quot;ESTABLISHED&quot;</code></li>
<li>查询网络连接的数量：<code>netstat -an | grep &quot;ESTABLISHED&quot; | wc -l</code></li>
</ul>
<h3 id="3-9-Bash-中其他特殊符号"><a href="#3-9-Bash-中其他特殊符号" class="headerlink" title="3.9 Bash 中其他特殊符号"></a>3.9 Bash 中其他特殊符号</h3><ul>
<li><code>&#39;&#39;</code>：单引号，在单引号中所有的特殊符号如：<code>$</code>，<code>反引号（数字1左面的键）</code>都没有特殊含义。</li>
<li><code>&quot;&quot;</code>：双引号，在双引号中特殊字符都没有特殊含义，但是 <code>$</code>，<code>反引号（数字1左面的键）</code>，<code>\</code>例外，其拥有“调用变量的值”、“引用命令”、“转义符”的特殊含义。</li>
<li><code>反引号</code>：反引号括起来的内容是系统命令，在 Bash 中会先执行，与 <code>$()</code> 的作用一样，推荐使用 <code>$()</code>。</li>
<li><code>$()</code>：用来引用系统命令。</li>
<li><code>$</code>：用于调用变量的值，例如：<code>$name</code> 调用 <code>name</code> 变量的值。</li>
<li><code>\</code>：转义符，跟在<code>\</code>之后的特殊符号将失去特殊含义，变为普通字符，例如：<code>\$</code>将输出 <code>$</code> 符号，而不是当作变量引用</li>
<li><code>#</code>：# 开头的行表示注释</li>
<li><code>()</code>：用于一串命令执行时，() 中的命令会在子 Shell 中运行，类似于局部作用域</li>
<li><code>&#123;&#125;</code>：用于一串命令执行时，{} 中的命令会在当前 Shell 中执行，也可用于变量变形与替换，其实和不加上大括号 {} 的作用是一样的</li>
</ul>
<p>父 Shell 和子 Shell:</p>
<ul>
<li>在当前的 Bash 中可以调用新 Bash，执行命令 <code>bash</code>。原来的 Bash 就相当于父 Bash，新建的 Bash 相当于子 Shell。退回到父 Shell，执行命令 <code>exit</code>。</li>
<li>执行 <code>pstree</code> 命令可以看到进程树，执行该命令前若未显示，可能需要安装相应的包，执行 <code>yum install psmisc</code> 进行安装（安装前记得挂载光盘镜像 <code>mount /dev/cdrom /mnt/cdrom</code>）。</li>
</ul>
<p>未创建子 Shell：<br><img src="https://i.loli.net/2021/03/20/tXAb5Ns7kKcVMJE.png" alt="image.png"><br>创建子 Shell：<br><img src="https://i.loli.net/2021/03/20/yCpdxg4oWVq1UPM.png" alt="image.png"></p>
<p><code>()</code> 和 <code>&#123;&#125;</code> 的区别：</p>
<ul>
<li><code>()</code> 执行一串命令时，是在新开的子 Shell 中执行；<code>&#123;&#125;</code> 是在当前 Shell 中执行</li>
<li><code>()</code> 最后一个命令可以不用分号；<code>&#123;&#125;</code> 最后一个命令一定要用分号</li>
<li><code>()</code>各命令不必和括号有空格；<code>&#123;&#125;</code> 第一个命令和左括号之间必须要有一个空格<br><img src="https://i.loli.net/2021/03/20/pIeHXMhyS4coCk6.png" alt="image.png"></li>
</ul>
<h2 id="4-Bash-变量和运算符"><a href="#4-Bash-变量和运算符" class="headerlink" title="4 Bash 变量和运算符"></a>4 Bash 变量和运算符</h2><h3 id="4-1-变量"><a href="#4-1-变量" class="headerlink" title="4.1 变量"></a>4.1 变量</h3><ul>
<li>变量名可以由字母、数字、下划线组成，但不能以数字开头</li>
<li>Bash 中，变量的默认类型都是字符串类型，如果要进行数值运算，则需修改变量类型为数值型</li>
<li>变量用等号连接值，等号两侧不能有空格</li>
<li>变量的值如果有空格，需要用双引号或者单引号包括，注意双引号和单引号的区别。例如：<code>name=&quot;hello world!&quot;</code></li>
<li>变量的值中，可以使用 / 转义符</li>
<li>如果增加变量的值，可以进行变量值的叠加。形式：<code>&quot;$变量名&quot;</code> 或 <code>$&#123;变量名&#125;</code>。例如：<code>name=$&#123;name&#125;123</code> 或者 <code>name=&quot;$name&quot;456</code></li>
</ul>
<h3 id="4-2-变量的分类"><a href="#4-2-变量的分类" class="headerlink" title="4.2 变量的分类"></a>4.2 变量的分类</h3><ul>
<li>用户自定义变量：用户自定义变量名、变量含义、变量内容</li>
<li>环境变量：<ul>
<li>用户自定义环境变量：用户自定义变量名、变量含义、变量内容</li>
<li>系统自带环境变量：变量名和变量含义由系统定义，变量的内容可由用户定义</li>
</ul>
</li>
<li>位置变量参数：这种变量主要用来向脚本中传递参数或数据的，变量名、变量含义是固定的，变量内容可自定义</li>
<li>预定义变量：Bash 中已经定义好的变量，变量名、变量含义是固定的，变量内容可自定义</li>
</ul>
<h3 id="4-3-用户自定义变量"><a href="#4-3-用户自定义变量" class="headerlink" title="4.3 用户自定义变量"></a>4.3 用户自定义变量</h3><ul>
<li>删除变量命令：<code>unset 变量名</code>，例如：<code>unset name</code> （注意这里没有$符号）</li>
<li>查看变量命令：<code>set</code></li>
<li>说明：<code>echo $未定义的变量</code> 会显示空，但如果先执行 <code>set -u</code> 再次打印未定义的变量时会有提示</li>
</ul>
<h3 id="4-4-环境变量"><a href="#4-4-环境变量" class="headerlink" title="4.4 环境变量"></a>4.4 环境变量</h3><p>用户自定义的环境变量和用户定义的普通变量的区别：普通变量只会在当前 Shell 中显示，而环境变量在父 Shell 和子 Shell 中都有。</p>
<ul>
<li>设置环境变量：<code>export age=&quot;18&quot;</code> 或者分成两条命令 <code>age=18</code>，<code>export age</code></li>
<li>删除环境变量：<code>unset 变量名</code>，例如：<code>unset age</code></li>
<li>查看环境变量：<code>env</code>（<code>set</code> 命令也会列出部分环境变量，二者列出的环境变量不同）</li>
</ul>
<p>系统默认环境变量：<br><img src="https://i.loli.net/2021/03/20/PudnBjoqUJT6M8X.png" alt="image.png"><br><img src="https://i.loli.net/2021/03/20/MOb9yBF8volfaLd.png" alt="image.png"><br><img src="https://i.loli.net/2021/03/20/RL4s9uGQA8bv7fI.png" alt="image.png"></p>
<p>特别说明下系统变量 PATH：</p>
<ul>
<li>含义：该变量保存的是系统查找命令的路径</li>
<li>PATH 变量的值是用 <code>:</code> 分割的路径，该路径就是系统查找命令的路径。</li>
<li>用 Shell 程序的文件名，执行该程序的方法：</li>
<li>可以将自己的 Shell 程序放在任何一个 PATH 变量定义的路径下，便可将该程序使用文件名执行，例如：<code>cp hello.sh /root/bin</code> </li>
<li>可以将程序所在的路径加入到 PATH 中，例如：<code>PATH=&quot;$PATH&quot;:程序所在路径</code>，注意这里一定要加上冒号，这只是临时生效，重启后就失效了。</li>
</ul>
<p>系统变量 PS1 变量：</p>
<ul>
<li>含义：用来定义命令提示符的，可以按自己的喜好定义命令提示符，但不推荐。</li>
</ul>
<p><img src="https://i.loli.net/2021/03/20/8c3fW6rEByGeUQK.png" alt="image.png"></p>
<p>系统变量 LANG 变量：</p>
<ul>
<li>含义：语系变量</li>
<li>查看 Linux 支持的语系：<code>locale -a | more</code> ，统计个数 <code>locale -a | wc -l</code></li>
<li>查看当前系统的语系：<code>locale</code></li>
</ul>
<h3 id="4-5-位置变量参数"><a href="#4-5-位置变量参数" class="headerlink" title="4.5 位置变量参数"></a>4.5 位置变量参数</h3><ul>
<li><code>$n</code>：n 为数字，<code>$0</code> 代表命令本身，$1-$9 代表第一到第九个参数，十个以上的参数需要用大括号包含，例如：<code>$&#123;10&#125;</code></li>
<li><code>$*</code>：这个变量代表命令行中的所有参数，$* 把所有的参数看成一个整体。（注意：”$*” 要用引号括起来）</li>
<li><code>$@</code>：这个变量代表命令行中的所有参数，但是 $@ 把每个参数区分对待</li>
<li><code>$#</code>：这个命令代表命令行中所有参数的个数</li>
</ul>
<h3 id="4-6-预定义变量"><a href="#4-6-预定义变量" class="headerlink" title="4.6 预定义变量"></a>4.6 预定义变量</h3><ul>
<li><code>$?</code>：最后一次执行命令的返回状态。如果这个变量的值为 0，证明上一个命令正确执行；如果这个变量的值非 0 （具体哪个数，由命令自己来决定），则证明上一个命令不正确</li>
<li><code>$$</code>：当前进程的进程号（PID）</li>
<li><code>$!</code>：后台运行的最后一个进程的进程号（PID）</li>
</ul>
<h3 id="4-7-接收键盘输入"><a href="#4-7-接收键盘输入" class="headerlink" title="4.7 接收键盘输入"></a>4.7 接收键盘输入</h3><ul>
<li><p>命令：<code>read [选项] [变量名]</code></p>
</li>
<li><p>选项：</p>
<ul>
<li><code>-p &quot;提示信息&quot;</code> 在等待read输入时，输出提示信息；</li>
<li><code>-t 秒数</code> read命令会一直等待用户输入，使用此选项用来限制等待时间；</li>
<li><code>-n 字符数</code> read命令只接受指定的字符数，就会执行</li>
<li><code>-s</code>：隐藏输入的数据</li>
</ul>
</li>
<li><p>变量名：</p>
<ul>
<li>变量名可以自己定义，如果不指定变量名，会把输入保存入默认变量 REPLY</li>
<li>如果只提供一个变量名，则整个输入行赋予该变量</li>
<li>如果提供一个以上的变量名，则输入行分为若干字，一个接一个的赋予各变量，命令行上的最后一个变量取得剩下的所有字</li>
</ul>
</li>
<li><p>例如：<code>read -t 30 -p &quot;please input a number:&quot; num</code></p>
</li>
</ul>
<h3 id="4-8-Shell-的运算符"><a href="#4-8-Shell-的运算符" class="headerlink" title="4.8 Shell 的运算符"></a>4.8 Shell 的运算符</h3><ol>
<li>数值运算的方法：</li>
</ol>
<p>使用 declare 声明变量的类型：</p>
<ul>
<li>命令：<code>declare [+/-][选项] 变量名</code></li>
<li>选项：</li>
<li><code>-</code>：给变量设定类型属性</li>
<li><code>+</code>：取消变量的类型属性</li>
<li><code>-a</code>：将变量声明为数组型</li>
<li><code>-i</code>：将变量声明为整数型（integer）</li>
<li><code>-r</code>：将变量声明为只读类型，只读变量不能改、不能删、也不能通过 +r 取消只读属性</li>
<li><code>-x</code>：将变量声明为环境变量，和 <code>export 变量名</code> 作用相同</li>
<li><code>-p</code>：显示指定变量的被声明类型</li>
</ul>
<p>使用 <code>expr</code> 或者 <code>let</code> 数值运算工具：</p>
<ul>
<li><code>expr</code>：要求运算符两侧必须有空格，<code>dd=$(expr $aa + $bb)</code>，expr $aa + $bb 相当于一个命令</li>
<li><code>let</code>：<code>let dd=$aa+$bb</code></li>
</ul>
<p>使用 <code>$((运算式))</code> 或者 <code>$[运算式]</code> 方式运算：（推荐使用双括号的形式）</p>
<ul>
<li><code>$((运算式))</code>：<code>dd=$(($aa+$bb))</code></li>
<li><code>$[运算式]</code>：<code>dd=$[$aa+$bb]</code></li>
</ul>
<p>Shell 常用运算符：<br><img src="https://i.loli.net/2021/03/22/t2uBmTh7YGxnl96.png" alt="image.png"><br><img src="https://i.loli.net/2021/03/22/92AkmfWzPdTgIJj.png" alt="image.png"></p>
<p>计算器实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">  </span><br><span class="line">read -t 30 -p &quot;input num1:&quot; num1</span><br><span class="line">read -t 30 -p &quot;input num2:&quot; num2</span><br><span class="line">read -n 1 -t 30 -p &quot;input operator +-*/:&quot; op</span><br><span class="line">echo -e &quot;\n&quot;</span><br><span class="line"></span><br><span class="line">[ &quot;$op&quot; == &quot;+&quot; ] &amp;&amp; echo &quot;$(($num1 + $num2))&quot; &amp;&amp; exit</span><br><span class="line">[ &quot;$op&quot; == &quot;-&quot; ] &amp;&amp; echo &quot;$(($num1 - $num2))&quot; &amp;&amp; exit</span><br><span class="line">[ &quot;$op&quot; == &quot;*&quot; ] &amp;&amp; echo &quot;$(($num1 * $num2))&quot; &amp;&amp; exit</span><br><span class="line">[ &quot;$op&quot; == &quot;/&quot; ] &amp;&amp; echo &quot;$(($num1 / $num2))&quot; &amp;&amp; exit</span><br><span class="line"></span><br><span class="line">echo &quot;please input right operator&quot;</span><br><span class="line">                                          </span><br></pre></td></tr></table></figure>
<p>注意：上述程序中 <code>[</code> 左面和 <code>]</code> 右面必须有空格</p>
<h3 id="4-9-变量的测试与内容置换"><a href="#4-9-变量的测试与内容置换" class="headerlink" title="4.9 变量的测试与内容置换"></a>4.9 变量的测试与内容置换</h3><p>变量测试的目的：测试下这个变量是什么值<br>测试的方法如下：（可以只记住一种测试方法就行）<br><img src="https://i.loli.net/2021/03/22/uB1p6IXF7NEfY4O.png" alt="image.png"></p>
<h2 id="5-环境变量配置文件"><a href="#5-环境变量配置文件" class="headerlink" title="5 环境变量配置文件"></a>5 环境变量配置文件</h2><h3 id="5-1-source-命令"><a href="#5-1-source-命令" class="headerlink" title="5.1 source 命令"></a>5.1 source 命令</h3><ul>
<li>命令：<code>source 配置文件</code> 或者 <code>. 配置文件</code></li>
<li>作用：重新执行刚刚修改的初始化文件，使之立即生效，而不必注销并重新登录</li>
</ul>
<h3 id="5-2-环境变量配置文件"><a href="#5-2-环境变量配置文件" class="headerlink" title="5.2 环境变量配置文件"></a>5.2 环境变量配置文件</h3><p>登录时生效的环境变量配置文件：</p>
<ul>
<li>/etc/profile</li>
<li>/etc/profile.d/*.sh</li>
<li>~/.bash_profile</li>
<li>~/.bashrc</li>
<li>/etc/bashrc</li>
</ul>
<p>注销时生效的环境变量配置文件：</p>
<ul>
<li>~/.bash_logout （前提是要执行 <code>logout</code> 命令）</li>
</ul>
<h3 id="5-3-Shell-登录信息"><a href="#5-3-Shell-登录信息" class="headerlink" title="5.3 Shell 登录信息"></a>5.3 Shell 登录信息</h3><ul>
<li>/etc/issue：登录本地终端时，会显示几行欢迎信息，这几行欢迎信息保存在文件 /etc/issue 文件中</li>
<li>/etc/issue.net：远程登录时，需要显示的欢迎信息</li>
<li>/etc/motd：显示欢迎信息，只是这个文件中的欢迎信息是在用户输入用户名和密码，正确登录之后显示欢迎信息，该欢迎信息不论是本地登录还是远程登录都可以显示；而 /etc/issue 和 /etc/issue.net 是在用户登录之前显示欢迎信息</li>
</ul>
<h3 id="5-4-定义-Bash-快捷键"><a href="#5-4-定义-Bash-快捷键" class="headerlink" title="5.4 定义 Bash 快捷键"></a>5.4 定义 Bash 快捷键</h3><ul>
<li>查询快捷键的命令：<code>stty -a</code></li>
<li>更改快捷键的命令（但是不建议修改）：<code>stty 关键字 快捷键</code></li>
</ul>
<h2 id="6-正则表达式"><a href="#6-正则表达式" class="headerlink" title="6 正则表达式"></a>6 正则表达式</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>正则表达式和通配符的区别：正则表达式用来在文件中匹配符合条件的字符串，通配符用来匹配符合条件的文件名。（该区别仅在 Shell 中适用）</p>
<ul>
<li>支持正则表达式的命令：<code>grep</code>、<code>awk</code>、<code>sed</code></li>
<li>支持通配符的命令：<code>ls</code>、<code>find</code>、<code>cp</code> （这些命令不支持正则表达式，所以只能使用 Shell 自己的通配符来进行匹配）</li>
</ul>
<h3 id="6-2-基础正则表达式"><a href="#6-2-基础正则表达式" class="headerlink" title="6.2 基础正则表达式"></a>6.2 基础正则表达式</h3><p>核心：含有匹配，只要含有正则表达式所展示的字符，就会列出结果<br>作用：用来做过滤操作，过滤掉一些不符合条件的文本内容</p>
<p>使用 <code>grep</code> 命令</p>
<ul>
<li><code>*</code>：前一个字符匹配 0 次或任意多次</li>
<li><code>.</code>：匹配除了换行以外的任意字符</li>
<li><code>^</code>：匹配行首</li>
<li><code>$</code>：匹配行尾</li>
<li><code>[]</code>：匹配中括号中指定的任意字符</li>
<li><code>[^]</code>：匹配除中括号的字符以外的任意一个字符。例如：[^0-9] 表示匹配任意一位非数字字符。（注意：<code>^</code>放在中括号内和中括号外的区别）</li>
<li><code>\</code>：转义符。用于将特殊符号的含义取消</li>
<li><code>\&#123;n\&#125;</code> 表示其前面的字符<strong>恰好</strong>出现了 n 次。（这里的左括号 { 和右括号 } 前面的右斜杠 \ 是转义符，目的是取消左括号和右括号的特殊含义。）</li>
<li><code>\&#123;n,\&#125;</code> 表示其前面的字符出现的次数<strong>不小于</strong> n 次</li>
<li><code>\&#123;n,m\&#125;</code> 表示其前面的字符至少出现 n 次，至多出现 m 次</li>
</ul>
<h3 id="6-3-扩展正则表达式"><a href="#6-3-扩展正则表达式" class="headerlink" title="6.3 扩展正则表达式"></a>6.3 扩展正则表达式</h3><p>Linux 其实是支持一些元字符，例如：“+”，“？”，“|”，“（）”。但是 <code>grep</code> 命令不支持。如果想要支持这些元字符，需要使用 <code>egrep</code> 或者 <code>grep -E</code> 命令，因此将这些元字符称为扩展元字符。</p>
<p>使用 <code>egrep</code> 或者 <code>grep -E</code> 命令</p>
<ul>
<li><code>+</code>：前一个字符匹配1次或任意多次</li>
<li><code>?</code>：前一个字符匹配0次或1次</li>
<li><code>|</code>：匹配两个或多个分支选择，例如：“was|his”</li>
<li><code>()</code>：匹配其为一个整体，例如：“(dog)+” 会匹配 “dog”，“dogdog”，“dogdogdog”等</li>
</ul>
<p>注意：扩展正则，也就是使用 <code>grep -E</code> 命令时，对于基础正则中的表示次数的 <code>\&#123;n\&#125;</code>、<code>\&#123;n,\&#125;</code>、<code>\&#123;n,m\&#125;</code> 不要写转义符，写成 <code>&#123;n,m&#125;</code>、<code>&#123;n,&#125;</code>、<code>&#123;n&#125;</code> </p>
<h2 id="7-字符串截取和替换命令"><a href="#7-字符串截取和替换命令" class="headerlink" title="7 字符串截取和替换命令"></a>7 字符串截取和替换命令</h2><h3 id="7-1-cut-列提取命令"><a href="#7-1-cut-列提取命令" class="headerlink" title="7.1 cut 列提取命令"></a>7.1 cut 列提取命令</h3><p>说明：<code>grep</code> 命令提取行，<code>cut</code> 命令提取列</p>
<ul>
<li>格式：<code>cut [选项] 文件名</code></li>
<li>选项：</li>
<li><code>-f 列号</code> 提取第几列（如果想提取多列，列号用逗号分开）</li>
<li><code>-d 分隔符</code> 按照指定分隔符分割（注意：<code>cut</code> 命令不能识别空格作为分隔符）</li>
<li><code>-c 字符范围</code> 不依赖分隔符来区分列，而是通过字符的下标，行首为0.<code>n-</code> 表示从第 n 个字符到结尾，<code>n-m</code> 从第 n 个字符到第 m 个字符，<code>-m</code> 表示从第 1 个字符到第 m 个字符</li>
</ul>
<h3 id="7-2-awk-编程"><a href="#7-2-awk-编程" class="headerlink" title="7.2 awk 编程"></a>7.2 awk 编程</h3><ol>
<li>printf 格式化输出</li>
</ol>
<ul>
<li>命令：<code>printf &#39;输出类型输出格式&#39; 输出内容</code></li>
<li>输出类型：<ul>
<li><code>%ns</code>：输出字符串，n 表示输出几个字符可以省略</li>
<li><code>%ni</code>：输出整数，n 表示输出几个数字可以省略</li>
<li><code>%m.nf</code>：输出浮点数，m 表示浮点数的位数（包括小数位），n 表示小数的位数，例如：<code>%8.2f</code> 表示输出 8 位数，其中 2 位是小数，6 位是整数</li>
</ul>
</li>
<li>输出格式：<ul>
<li><code>\n</code>：回车</li>
<li><code>\a</code>：输出警告音</li>
<li><code>\b</code>：输出退格键</li>
<li><code>\f</code>：清除屏幕</li>
<li><code>\r</code>：回车，也就是 Enter 键</li>
<li><code>\t</code>：水平输出退格键，Tab 键</li>
<li><code>\v</code>：垂直输出退格键，Tab 键</li>
</ul>
</li>
<li>例如：<code>printf &#39;%s\t %s\t %s\t %s\t\n&#39; $(cat student.txt)</code></li>
</ul>
<ol start="2">
<li>awk 基本使用</li>
</ol>
<ul>
<li>命令格式：<code>awk &#39;条件1&#123;动作1&#125; 条件2&#123;动作2&#125;...&#39; 文件名</code></li>
<li>条件：一般使用关系表达式作为条件</li>
<li>动作：格式化输出（print 或 printf，注意：其中的引号要用双引号）；流程控制语句</li>
<li>例子：<code>awk &#39;&#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#39; student.txt</code> （$2 表示第 2 列）</li>
<li>特别说明：<code>cut</code> 命令不能识别空格作为分隔符符，可以借助 <code>awk</code> 命令</li>
</ul>
<p>awk 的条件：</p>
<ul>
<li>awk 保留字：<ul>
<li><code>BEGIN</code>：在 awk 程序一开始时，尚未读取任何数据之前执行，只会执行一次。例如：<code>awk &#39;BEGIN&#123;printf &quot;this is a dog\n&quot;&#125; &#123;printf $2 &quot;\t&quot; $3 &quot;\n&quot;&#125;&#39; student.txt</code> （说明：<code>awk</code> 命令有点像循环，对 student.txt 文件中的每一行内容执行 {printf $2 “\t” $3 “\n”}）</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/03/23/hIo1sUdC7ejWGmE.png" alt="image.png"></p>
<ul>
<li><code>END</code>：在 awk 程序处理完所有数据，即将结束时执行，只会执行 1 次。例如：<code>awk &#39;END&#123;printf &quot;this is a dog\n&quot;&#125; &#123;printf $2 &quot;\t&quot; $3 &quot;\n&quot;&#125;&#39; student.txt</code></li>
<li>关系运算符：<ul>
<li><code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>==</code>、<code>!=</code></li>
<li><code>A~B</code>：判断字符串 A 中是否包含能匹配 B 表达式的子字符串</li>
<li><code>A!~B</code>：判断字符串 A 中是否不包含能匹配 B 表达式的子字符串</li>
</ul>
</li>
<li>正则表达式：<code>/正则/</code> </li>
</ul>
<p>awk 内置变量：</p>
<ul>
<li><code>$0</code>：代表目前 awk 所读入的整行数据，awk 是一行一行的读入数据</li>
<li><code>$n</code>：代表目前读入行第 n 个字段</li>
<li><code>NF</code>：当前拥有的字段（列）总数</li>
<li><code>NR</code>：当前 awk 所处理的行，是总数据的第几行</li>
<li><code>FS</code>：用户定义分隔符，awk 默认分隔符是任意空格，如果想要使用其他分隔符就要使用 FS 变量定义，例如：<code>FS=&quot;:&quot;</code></li>
<li>举例1：<code>grep &quot;/bin/bash&quot; /etc/passwd | awk &#39;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\t&quot; $3 &quot;\n&quot;&#125;&#39;</code> （注意：这里只有加了 BEGIN 才能保证对文件 /etc/passwd 中的第一行的内容生效）</li>
<li>举例2：<code>grep &quot;/bin/bash&quot; /etc/passwd | awk &#39;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\t&quot; $3 &quot;\t行号：&quot; NR &quot;\t 字段数：&quot; NF &quot;\n&quot;&#125;&#39;</code></li>
</ul>
<h3 id="7-3-sed-命令"><a href="#7-3-sed-命令" class="headerlink" title="7.3 sed 命令"></a>7.3 sed 命令</h3><p>sed 命令作用：用来对文件中的文本进行选取、替换、删除、新增。</p>
<ul>
<li><p>格式：<code>sed [选项] &#39;[动作]&#39; 文件名</code></p>
</li>
<li><p>选项：</p>
<ul>
<li><code>-n</code>：sed 命令会把所有数据都输出到屏幕，如果加入此选项，只会将经过 sed 命令处理的行输出到屏幕</li>
<li><code>-e</code>：允许对输入数据应用多条 sed 命令编辑，多个动作之间要用分号分割开</li>
<li><code>-f 脚本文件名</code>：从 sed 脚本中读入 sed 操作。（不常用）</li>
<li><code>-r</code>：在 sed 中支持扩展正则表达式</li>
<li><code>-i</code>：用 sed 的修改结果直接修改读取数据的文件，而不是由屏幕输出</li>
</ul>
</li>
<li><p>动作：</p>
<ul>
<li><code>行范围a \</code>：追加（append），在当前行最后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用 <code>\</code> 代表数据未完结，如果只添加一行，就不用加 <code>\</code></li>
<li><code>行范围c 替换的内容\</code>：行替换，用 c 后面的字符串替换原数据行</li>
<li><code>行范围i \</code>：插入（insert），在当前行之前插入一行或多行</li>
<li><code>行范围d</code>：删除（delete），删除指定行</li>
<li><code>行范围p</code>：打印（print），输出指定行</li>
<li><code>s</code>：字符串替换，用一个字符串替换另外一个字符串。<code>行范围s/旧字符串/新字符串/g</code></li>
<li>说明：多行可用逗号分隔，例如：<code>&#39;2,4p&#39;</code></li>
</ul>
</li>
<li><p>举例：<code>sed -i &#39;3i &quot;1234321&quot;&#39; student.txt</code></p>
</li>
</ul>
<h2 id="8-字符处理命令"><a href="#8-字符处理命令" class="headerlink" title="8 字符处理命令"></a>8 字符处理命令</h2><h3 id="8-1-排序命令-sort"><a href="#8-1-排序命令-sort" class="headerlink" title="8.1 排序命令 sort"></a>8.1 排序命令 sort</h3><ul>
<li><p>命令格式：<code>sort [选项] 文件名</code></p>
</li>
<li><p>选项：</p>
<ul>
<li><code>-f</code>：忽略大小写</li>
<li><code>-b</code>：忽略每行前面的空白部分</li>
<li><code>-n</code>：以数值型进行排序，默认使用字符串型进行排序</li>
<li><code>-r</code>：反向排序</li>
<li><code>-u</code>：删除重复行，就是 <code>uniq</code> 命令 </li>
<li><code>-t</code>：指定分隔符，默认分隔符是制表符</li>
<li><code>-k n[,m]</code>：按照指定的字段范围排序，从第 n 字段开始，到第 m 字段结束（默认到行尾）</li>
</ul>
</li>
<li><p>举例：<code>sort -n -t &quot;:&quot; -k 3,3 /etc/passwd</code> （将文件 /etc/passwd 中，按照冒号分割的第三列的数值型排序）</p>
</li>
</ul>
<h3 id="8-2-uniq-命令"><a href="#8-2-uniq-命令" class="headerlink" title="8.2 uniq 命令"></a>8.2 uniq 命令</h3><ul>
<li>命令格式：<code>uniq [选项] 文件名</code></li>
<li>选项：<code>-i</code> 忽略大小写</li>
<li>作用：取消重复的行</li>
</ul>
<h3 id="8-3-wc-统计命令"><a href="#8-3-wc-统计命令" class="headerlink" title="8.3 wc 统计命令"></a>8.3 wc 统计命令</h3><ul>
<li>命令格式：<code>wc [选项] 文件名</code></li>
<li>选项：</li>
<li><code>-l</code>：只统计行</li>
<li><code>-w</code>：只统计单词数</li>
<li><code>-m</code>：只统计字符数</li>
</ul>
<h2 id="9-条件判断"><a href="#9-条件判断" class="headerlink" title="9 条件判断"></a>9 条件判断</h2><h3 id="9-1-按照文件类型进行判断"><a href="#9-1-按照文件类型进行判断" class="headerlink" title="9.1 按照文件类型进行判断"></a>9.1 按照文件类型进行判断</h3><p>文件类型选项：</p>
<ul>
<li><code>-b 文件</code>：判断文件是否存在，并且为块设备文件</li>
<li><code>-c 文件</code>：判断该文件是否存在，并且是否为字符设备文件</li>
<li><code>-d 文件</code>：判断文件是否存在，并且是否为目录文件</li>
<li><code>-e 文件</code>：判断文件是否存在</li>
<li><code>-f 文件</code>：判断文件是否存在，并且是否为普通文件</li>
<li><code>-L 文件</code>：判断文件是否存在，并且是否为链接文件</li>
<li><code>-p 文件</code>：判断文件是否存在，并且是否为管道文件</li>
<li><code>-s 文件</code>：判断文件是否存在，并且是否为非空</li>
<li><code>-S 文件</code>：判断文件是否存在，并且是否为套接字文件</li>
</ul>
<p>命令格式：（推荐使用第一种）</p>
<ul>
<li><code>[ 文件类型选项 文件名 ]</code>：例如 <code>[ d /root/123 ]</code> （特别注意：左括号的右侧和右括号的左侧都要有空格）</li>
<li><code>test 文件类型选项 文件名</code>：例如 <code>test -d /root/123</code></li>
<li>说明：可以用命令 <code>$?</code> 来查看执行完上述命令的返回结果，或者 <code>test -d /root/123 &amp;&amp; echo yes || echo no</code></li>
</ul>
<h3 id="9-2-按照文件权限进行判断"><a href="#9-2-按照文件权限进行判断" class="headerlink" title="9.2 按照文件权限进行判断"></a>9.2 按照文件权限进行判断</h3><p>文件权限选项：</p>
<ul>
<li><code>-r 文件</code>：判断文件是否存在，并且该文件是否有读权限</li>
<li><code>-w 文件</code>：判断文件是否存在，并且该文件是否有写权限</li>
<li><code>-x 文件</code>：判断文件是否存在，并且该文件是否有执行权限</li>
<li><code>-u 文件</code>：判断文件是否存在，并且该文件是否有 SUID 权限</li>
<li><code>-g 文件</code>：判断文件是否存在，并且文件是否有 SGID 权限</li>
<li><code>-k 文件</code>：判断文件是否存在，并且是否有 SBit 权限</li>
</ul>
<h3 id="9-3-两文件之间进行比较"><a href="#9-3-两文件之间进行比较" class="headerlink" title="9.3 两文件之间进行比较"></a>9.3 两文件之间进行比较</h3><ul>
<li><code>文件1 -nt 文件2</code>：判断文件 1 的修改时间是否比文件 2 的新</li>
<li><code>文件1 -ot 文件2</code>：判断文件 1 的修改时间是否比文件 2 的旧</li>
<li><code>文件1 -ef 文件2</code>：判断文件 1 是否和文件 2 的 Inode 号一致，可以理解为两个文件是否为同一文件</li>
<li>举例：判断两个文件是否为硬链接：<ul>
<li>创建硬链接：<code>ln /root/sh/student.txt /tmp/stu.txt</code></li>
<li>判断：<code>[ /root/sh/student.txt -ef /tmp/stu.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</code></li>
</ul>
</li>
</ul>
<h3 id="9-4-两个整数之间进行比较"><a href="#9-4-两个整数之间进行比较" class="headerlink" title="9.4 两个整数之间进行比较"></a>9.4 两个整数之间进行比较</h3><ul>
<li><code>整数1 -eq 整数2</code>：整数1是否等于（equal）整数2</li>
<li><code>整数1 -ne 整数2</code>：整数1是否不等于（not equal）整数2</li>
<li><code>整数1 -gt 整数2</code>：整数1是否大于（greater than）整数2</li>
<li><code>整数1 -lt 整数2</code>：整数1是否小于（less than）整数2</li>
<li><code>整数1 -ge 整数2</code>：整数1是否大于等于（greater than）整数2</li>
<li><code>整数1 -le 整数2</code>：整数1是否小于等于（less than）整数2</li>
</ul>
<h3 id="9-5-字符串的判断"><a href="#9-5-字符串的判断" class="headerlink" title="9.5 字符串的判断"></a>9.5 字符串的判断</h3><ul>
<li><code>-z 字符串</code>：判断字符串是否为空</li>
<li><code>-n 字符串</code>：判断字符串是否非空</li>
<li><code>字符串1 == 字符串2</code>：判断字符串1是否和字符串2是否相等</li>
<li><code>字符串1 != 字符串2</code>：判断字符串1是否和字符串2是否不等</li>
</ul>
<h3 id="9-6-多重条件判断"><a href="#9-6-多重条件判断" class="headerlink" title="9.6 多重条件判断"></a>9.6 多重条件判断</h3><ul>
<li><code>判断1 -a 判断2</code>：逻辑与（and）</li>
<li><code>判断1 -o 判断2</code>：逻辑或（or）</li>
<li><code>! 判断</code>：取反</li>
</ul>
<h2 id="10-流程控制"><a href="#10-流程控制" class="headerlink" title="10 流程控制"></a>10 流程控制</h2><h3 id="10-1-if-条件判断"><a href="#10-1-if-条件判断" class="headerlink" title="10.1 if 条件判断"></a>10.1 if 条件判断</h3><ol>
<li>单分支 if 条件语句<br>语法格式：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">    程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
或者<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [条件判断式]</span><br><span class="line">    then</span><br><span class="line">        程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>举例：判断根分区的使用率是否大于 10</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">a=$(df -h | grep &quot;/dev/sda5&quot; | awk &#x27;&#123;printf $5&#125;&#x27; | awk &#x27;BEGIN&#123;FS=&quot;%&quot;&#125; &#123;printf $1&#125;&#x27; )</span><br><span class="line">if [ $a -gt 10 ]</span><br><span class="line">    then echo &quot;1111111111111111&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>双分支 if 条件语句</li>
</ol>
<p>语法格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">    then </span><br><span class="line">        条件成立时，执行的程序</span><br><span class="line">    else</span><br><span class="line">        条件不成立时，执行的程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>举例：判断 apache 服务是否开启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"> aa=$(netstat -tuln | awk &#x27;&#123;printf $4&quot;\n&quot;&#125;&#x27;| grep &quot;:80$&quot;)</span><br><span class="line"> if [ &quot;$aa&quot; == &quot;&quot; ]</span><br><span class="line">    then</span><br><span class="line">        echo &quot;restart httpd&quot;</span><br><span class="line">        service httpd start &amp;&gt;/dev/null</span><br><span class="line">    else</span><br><span class="line">        echo &quot;ok&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<ul>
<li>开启 httpd 服务的命令：<code>service httpd start</code></li>
<li>关闭 httpd 服务的命令：<code>service httpd stop</code></li>
<li><code>命令 &amp;&gt;/dev/null</code> 是将命令执行过程显示的信息写在 /dev/null 文件中<br>说明：使用 <code>nmap -sT</code> （-s 扫描，-T 扫描所有 TCP 开启的端口）命令也可以检测 httpd 服务是否开启，即查看 80 端口。若 nmap 未安装，需要使用 <code>yum -y install nmap</code>，安装之前需要挂载镜像 <code>mount /dev/cdrom /mnt/cdrom</code></li>
</ul>
<ol start="3">
<li>多分支 if 条件语句</li>
</ol>
<p>语法格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断1 ]</span><br><span class="line">    then </span><br><span class="line">        当条件判断式 1 成立时，执行程序 1</span><br><span class="line">elif [ 条件判断式2 ]</span><br><span class="line">    then</span><br><span class="line">        当条件判断式 2 成立时，执行程序 2</span><br><span class="line">...省略更多条件...</span><br><span class="line">else</span><br><span class="line">    当所有条件都不成立时，最后执行此程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>举例：判断当前输入的是文件名还是目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">read -t 30 -p &quot;please input a filename:&quot; filename</span><br><span class="line"></span><br><span class="line">if [ -z $filename ]</span><br><span class="line">    then</span><br><span class="line">        echo &quot;file name is empty&quot;</span><br><span class="line">        exit 1</span><br><span class="line">elif [ ! -e $filename ]</span><br><span class="line">    then</span><br><span class="line">        echo &quot;file name is not exist&quot;</span><br><span class="line">        exit 2</span><br><span class="line">elif [ -f $filename ]</span><br><span class="line">    then</span><br><span class="line">        echo &quot;$filename is a putong file&quot;</span><br><span class="line">        exit 3</span><br><span class="line">elif [ -d $filename ]</span><br><span class="line">    then</span><br><span class="line">        echo &quot;$filename is a directory&quot;</span><br><span class="line">        exit 4</span><br><span class="line">else</span><br><span class="line">        echo &quot;$filename is other file&quot;</span><br><span class="line">        exit 5</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="10-2-多分支-case-条件语句"><a href="#10-2-多分支-case-条件语句" class="headerlink" title="10.2 多分支 case 条件语句"></a>10.2 多分支 case 条件语句</h3><p>case 语句只能判断一种条件关系，而 if 语句可以判断多种条件关系</p>
<p>语法格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">    &quot;值1&quot;)</span><br><span class="line">        如果变量的值等于值 1，则执行程序 1</span><br><span class="line">        ;;</span><br><span class="line">    &quot;值2&quot;)</span><br><span class="line">        如果变量的值等于值 2，则执行程序 2</span><br><span class="line">        ;;</span><br><span class="line">    ...省略其他分支...</span><br><span class="line">    *)</span><br><span class="line">        如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">read -t 30 -p &quot;plese input a number:&quot; number</span><br><span class="line">case $number in</span><br><span class="line">    &quot;1&quot;)</span><br><span class="line">        echo &quot;go to beijing&quot;</span><br><span class="line">        ;;</span><br><span class="line">    &quot;2&quot;)</span><br><span class="line">        echo &quot;go to shanghai&quot;</span><br><span class="line">        ;;</span><br><span class="line">    &quot;3&quot;)</span><br><span class="line">        echo &quot;go to tianjin&quot;</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;stay at home&quot;</span><br><span class="line">        ;;</span><br><span class="line">esac          </span><br></pre></td></tr></table></figure>

<h3 id="10-3-for-循环"><a href="#10-3-for-循环" class="headerlink" title="10.3 for 循环"></a>10.3 for 循环</h3><p>语法格式一：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3 ...</span><br><span class="line">    do</span><br><span class="line">        程序</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>
<p>语法格式二：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">    do</span><br><span class="line">        程序</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>

<p>举例1：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">for i in 1 2 3 4 5 </span><br><span class="line">        do  </span><br><span class="line">                echo &quot;$i&quot;</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举例2：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line"></span><br><span class="line">for(( i=1;i&lt;=10;i++ ))</span><br><span class="line">        do  </span><br><span class="line">                s=$(( $s+$i ))</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">echo &quot;$s&quot;</span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<p>说明：第一种语法格式更常用，举一个批量解压缩的例子。<br>写法一：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">cd /root/sh/tar</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将压缩包名写入日志文件中，目的是统计压缩包的个数</span></span><br><span class="line">ls *.tar.gz &gt; tar.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计压缩包的个数</span></span><br><span class="line">aa=$(cat tar.log | wc -l)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压缩</span></span><br><span class="line">for(( i=1; i&lt;=&quot;$aa&quot;; ++i))</span><br><span class="line">    do</span><br><span class="line">        tar -zxvf $(cat tar.log | awk &#x27;NR==&#x27;$i&#x27; &#123;print $1&#125;&#x27;) -C /root/sh/tar</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>

<p>写法二：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cd /root/sh/tar</span><br><span class="line"></span><br><span class="line">ls *.tar.gz &gt; tar.log</span><br><span class="line"></span><br><span class="line">for i in $(cat tar.log)</span><br><span class="line">    do</span><br><span class="line">        tar -zxvf $i -C /root/sh/tar &gt;&amp;/dev/null</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>

<p>举例：批量添加用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">read -t 30 -p &quot;please input a name:&quot; name</span><br><span class="line">read -t 30 -p &quot;please input number of user:&quot; user</span><br><span class="line">read -t 30 -p &quot;please input number of passwd:&quot; passwd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ -n $name -a -n $user -a -n $passwd ]</span><br><span class="line">        then</span><br><span class="line">                # 利用将 user 变量中所有的数字替换为空的方式，来判断 user 中是否全部为数字</span><br><span class="line">                y=$(echo $user | sed &#x27;s/[0-9]//g&#x27;)</span><br><span class="line">                if [ -z $y ]</span><br><span class="line">                        then</span><br><span class="line">                                for(( i=1; i&lt;=$user; ++i))</span><br><span class="line">                                        do  </span><br><span class="line">                                                # 新建用户</span><br><span class="line">                                                /usr/sbin/useradd &quot;$name$i&quot; &amp;&gt; /dev/null</span><br><span class="line">                                                # 将用户的初始密码设置为 passwd</span><br><span class="line">                                                echo $passwd | /usr/bin/passwd --stdin &quot;$name$i&quot; &amp;&gt; /dev/null</span><br><span class="line">                                                # 用户登录时，强制用户修改密码</span><br><span class="line">                                                chage -d 0 &quot;$name$i&quot; &amp;&gt; /dev/null</span><br><span class="line">                                        done</span><br><span class="line">                fi  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="10-4-while-循环"><a href="#10-4-while-循环" class="headerlink" title="10.4 while 循环"></a>10.4 while 循环</h3><p>代码格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">    do</span><br><span class="line">        程序</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>
<h3 id="10-5-until-循环"><a href="#10-5-until-循环" class="headerlink" title="10.5 until 循环"></a>10.5 until 循环</h3><p>代码格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until [ 条件判断式（程序中止条件） ]</span><br><span class="line">    do</span><br><span class="line">        程序</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>

<h2 id="11-特殊流程控制语句"><a href="#11-特殊流程控制语句" class="headerlink" title="11 特殊流程控制语句"></a>11 特殊流程控制语句</h2><h3 id="11-1-exit-语句"><a href="#11-1-exit-语句" class="headerlink" title="11.1 exit 语句"></a>11.1 exit 语句</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit [返回值]</span><br></pre></td></tr></table></figure>
<p>注：该返回值可通过 <code>echo $?</code> 命令进行查看</p>
<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">read -t 30 -p &quot;please input  a number:&quot; number</span><br><span class="line"></span><br><span class="line">y=$(echo $number | sed &#x27;s/[0-9]//g&#x27;)</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$y&quot; ]</span><br><span class="line">        then</span><br><span class="line">                # 变量 y 不是空，说明当前输入的不完全是数字</span><br><span class="line">                echo &quot;please input right number&quot;</span><br><span class="line">                exit 14</span><br><span class="line">        else</span><br><span class="line">                echo &quot;yes : $number&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="11-2-break-语句"><a href="#11-2-break-语句" class="headerlink" title="11.2 break 语句"></a>11.2 break 语句</h3><p><code>break</code> 作用：结束整个循环</p>
<h3 id="11-3-continue-语句"><a href="#11-3-continue-语句" class="headerlink" title="11.3 continue 语句"></a>11.3 continue 语句</h3><p><code>continue</code> 作用：结束本次循环，继续执行下一次</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
</search>
